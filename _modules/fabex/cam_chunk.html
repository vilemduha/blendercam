
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>fabex.cam_chunk &#8212; Fabex 1.0.65 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=38568b08"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/fabex/cam_chunk';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/Fabex_logo_square.png" class="logo__image only-light" alt="Fabex 1.0.65 documentation - Home"/>
    <script>document.write(`<img src="../../_static/Fabex_logo_square.png" class="logo__image only-dark" alt="Fabex 1.0.65 documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pppalain/blendercam" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://riot.im/app/#/room/#blendercam:matrix.org" title="Matrix" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-comments fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Matrix</span></a>
        </li>
</ul></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../users.html">User Guide</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../starting.html">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../interface.html">User Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tools.html">Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../strategies.html">Strategies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../examplechain.html">Example Chain Workflow</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../faq.html">FAQ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../developers.html">Developer Guide</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../../overview.html">Code Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../style.html">Style Guide</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../testing.html">Test Suite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../workflows.html">Workflows &amp; Actions</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../autoapi/index.html">API Reference</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../autoapi/fabex/index.html">fabex</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/bas_relief/index.html">fabex.bas_relief</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/bridges/index.html">fabex.bridges</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/cam_chunk/index.html">fabex.cam_chunk</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/collision/index.html">fabex.collision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/constants/index.html">fabex.constants</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/engine/index.html">fabex.engine</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/exception/index.html">fabex.exception</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/gcode_import_parser/index.html">fabex.gcode_import_parser</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/gcode_path/index.html">fabex.gcode_path</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/involute_gear/index.html">fabex.involute_gear</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/joinery/index.html">fabex.joinery</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../autoapi/fabex/operators/index.html">fabex.operators</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/async_op/index.html">fabex.operators.async_op</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/bas_relief_ops/index.html">fabex.operators.bas_relief_ops</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/bridges_op/index.html">fabex.operators.bridges_op</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/chain_ops/index.html">fabex.operators.chain_ops</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/curve_create_ops/index.html">fabex.operators.curve_create_ops</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/curve_equation_ops/index.html">fabex.operators.curve_equation_ops</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/curve_tools_ops/index.html">fabex.operators.curve_tools_ops</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/gcode_import_op/index.html">fabex.operators.gcode_import_op</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/operation_ops/index.html">fabex.operators.operation_ops</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/orient_op/index.html">fabex.operators.orient_op</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/pack_op/index.html">fabex.operators.pack_op</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/path_ops/index.html">fabex.operators.path_ops</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/position_op/index.html">fabex.operators.position_op</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/preset_ops/index.html">fabex.operators.preset_ops</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/simulation_ops/index.html">fabex.operators.simulation_ops</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/operators/slice_op/index.html">fabex.operators.slice_op</a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/pack/index.html">fabex.pack</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/parametric/index.html">fabex.parametric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/pattern/index.html">fabex.pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/preferences/index.html">fabex.preferences</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../autoapi/fabex/properties/index.html">fabex.properties</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/properties/chain_props/index.html">fabex.properties.chain_props</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/properties/info_props/index.html">fabex.properties.info_props</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/properties/interface_props/index.html">fabex.properties.interface_props</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/properties/machine_props/index.html">fabex.properties.machine_props</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/properties/material_props/index.html">fabex.properties.material_props</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/properties/movement_props/index.html">fabex.properties.movement_props</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/properties/operation_props/index.html">fabex.properties.operation_props</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/properties/optimisation_props/index.html">fabex.properties.optimisation_props</a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/puzzle_joinery/index.html">fabex.puzzle_joinery</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/simulation/index.html">fabex.simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/slice/index.html">fabex.slice</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/strategy/index.html">fabex.strategy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/testing/index.html">fabex.testing</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../autoapi/fabex/utilities/index.html">fabex.utilities</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/addon_utils/index.html">fabex.utilities.addon_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/async_utils/index.html">fabex.utilities.async_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/bounds_utils/index.html">fabex.utilities.bounds_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/chunk_utils/index.html">fabex.utilities.chunk_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/compare_utils/index.html">fabex.utilities.compare_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/dict_utils/index.html">fabex.utilities.dict_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/geom_utils/index.html">fabex.utilities.geom_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/image_utils/index.html">fabex.utilities.image_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/index_utils/index.html">fabex.utilities.index_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/loop_utils/index.html">fabex.utilities.loop_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/machine_utils/index.html">fabex.utilities.machine_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/material_utils/index.html">fabex.utilities.material_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/numba_utils/index.html">fabex.utilities.numba_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/ocl_utils/index.html">fabex.utilities.ocl_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/operation_utils/index.html">fabex.utilities.operation_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/orient_utils/index.html">fabex.utilities.orient_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/shapely_utils/index.html">fabex.utilities.shapely_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/simple_utils/index.html">fabex.utilities.simple_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/strategy_utils/index.html">fabex.utilities.strategy_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/thread_utils/index.html">fabex.utilities.thread_utils</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../autoapi/fabex/utilities/version_utils/index.html">fabex.utilities.version_utils</a></li>
</ul>
</details></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/version/index.html">fabex.version</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/fabex/voronoi/index.html">fabex.voronoi</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for fabex.cam_chunk</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Fabex &#39;cam_chunk.py&#39; © 2012 Vilem Novak</span>

<span class="sd">Classes and Functions to build, store and optimize CAM path chunks.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">ceil</span><span class="p">,</span>
    <span class="n">cos</span><span class="p">,</span>
    <span class="n">hypot</span><span class="p">,</span>
    <span class="n">pi</span><span class="p">,</span>
    <span class="n">sin</span><span class="p">,</span>
    <span class="n">sqrt</span><span class="p">,</span>
    <span class="n">tan</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">random</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">shapely</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">shapely</span><span class="w"> </span><span class="kn">import</span> <span class="n">ops</span> <span class="k">as</span> <span class="n">sops</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">shapely</span><span class="w"> </span><span class="kn">import</span> <span class="n">geometry</span> <span class="k">as</span> <span class="n">sgeometry</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">polygon</span> <span class="k">as</span> <span class="n">spolygon</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">MultiPolygon</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">ocl</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">opencamlib</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ocl</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">pass</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">bpy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mathutils</span><span class="w"> </span><span class="kn">import</span> <span class="n">Vector</span><span class="p">,</span> <span class="n">Euler</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">bl_ext.blender_org.simplify_curves_plus</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">curve_simplify</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.collision</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_sample_bullet</span><span class="p">,</span>
    <span class="n">get_sample_bullet_n_axis</span><span class="p">,</span>
    <span class="n">prepare_bullet_collision</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">OCL_SCALE</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.exception</span><span class="w"> </span><span class="kn">import</span> <span class="n">CamException</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.utilities.async_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">progress_async</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utilities.chunk_utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">rotate_point_by_point</span><span class="p">,</span>
    <span class="n">_internal_x_y_distance_to</span><span class="p">,</span>
    <span class="n">mesh_from_curve</span><span class="p">,</span>
    <span class="n">chunks_to_shapely</span><span class="p">,</span>
    <span class="n">parent_child</span><span class="p">,</span>
    <span class="n">parent_child_distance</span><span class="p">,</span>
    <span class="n">get_closest_chunk</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utilities.image_utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_sample_image</span><span class="p">,</span>
    <span class="n">prepare_area</span><span class="p">,</span>
    <span class="n">render_sample_image</span><span class="p">,</span>
    <span class="n">get_circle_binary</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utilities.numba_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">jit</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utilities.ocl_utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">oclSample</span><span class="p">,</span>
    <span class="n">get_oclSTL</span><span class="p">,</span>
    <span class="n">ocl_sample</span><span class="p">,</span>
    <span class="n">oclWaterlineLayerHeights</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utilities.shapely_utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">shapely_to_coordinates</span><span class="p">,</span>
    <span class="n">shapely_to_curve</span><span class="p">,</span>
    <span class="n">shapely_to_multipolygon</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utilities.simple_utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">activate</span><span class="p">,</span>
    <span class="n">distance_2d</span><span class="p">,</span>
    <span class="n">progress</span><span class="p">,</span>
    <span class="n">select_multiple</span><span class="p">,</span>
    <span class="n">timing_add</span><span class="p">,</span>
    <span class="n">timing_init</span><span class="p">,</span>
    <span class="n">timing_start</span><span class="p">,</span>
    <span class="n">tuple_add</span><span class="p">,</span>
    <span class="n">tuple_multiply</span><span class="p">,</span>
    <span class="n">tuple_subtract</span><span class="p">,</span>
    <span class="n">is_vertical_limit</span><span class="p">,</span>
    <span class="n">get_cache_path</span><span class="p">,</span>
<span class="p">)</span>


<span class="c1"># for building points - stores points as lists for easy insert /append behaviour</span>
<div class="viewcode-block" id="CamPathChunkBuilder">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunkBuilder">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CamPathChunkBuilder</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">startpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">inpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">inpoints</span> <span class="o">=</span> <span class="p">[]</span>
<div class="viewcode-block" id="CamPathChunkBuilder.points">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunkBuilder.points">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">inpoints</span></div>

<div class="viewcode-block" id="CamPathChunkBuilder.startpoints">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunkBuilder.startpoints">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">startpoints</span> <span class="o">=</span> <span class="n">startpoints</span> <span class="ow">or</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="CamPathChunkBuilder.endpoints">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunkBuilder.endpoints">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span> <span class="o">=</span> <span class="n">endpoints</span> <span class="ow">or</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="CamPathChunkBuilder.rotations">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunkBuilder.rotations">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotations</span> <span class="o">=</span> <span class="n">rotations</span> <span class="ow">or</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="CamPathChunkBuilder.depth">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunkBuilder.depth">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="CamPathChunkBuilder.to_chunk">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunkBuilder.to_chunk">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_chunk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">CamPathChunk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">startpoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotations</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">chunk</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chunk</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span>

        <span class="k">return</span> <span class="n">chunk</span></div>
</div>



<span class="c1"># an actual chunk - stores points as numpy arrays</span>
<div class="viewcode-block" id="CamPathChunk">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">CamPathChunk</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inpoints</span><span class="p">,</span> <span class="n">startpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># name this as _points so nothing external accesses it directly</span>
        <span class="c1"># for 3 axes, this is only storage of points. For N axes, here go the sampled points</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inpoints</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inpoints</span><span class="p">)</span>
<div class="viewcode-block" id="CamPathChunk.poly">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.poly">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># get polygon just in time</span></div>

<div class="viewcode-block" id="CamPathChunk.simppoly">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.simppoly">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">simppoly</span> <span class="o">=</span> <span class="kc">None</span></div>

        <span class="k">if</span> <span class="n">startpoints</span><span class="p">:</span>
            <span class="c1"># from where the sweep test begins, but also retract point for given path</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">startpoints</span> <span class="o">=</span> <span class="n">startpoints</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">startpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">endpoints</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span> <span class="o">=</span> <span class="n">endpoints</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># where sweep test ends</span>
        <span class="k">if</span> <span class="n">rotations</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotations</span> <span class="o">=</span> <span class="n">rotations</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotations</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># rotation of the machine axes</span>
<div class="viewcode-block" id="CamPathChunk.closed">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.closed">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="CamPathChunk.children">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.children">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="CamPathChunk.parents">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.parents">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">parents</span> <span class="o">=</span> <span class="p">[]</span></div>

        <span class="c1"># self.unsortedchildren=False</span>
<div class="viewcode-block" id="CamPathChunk.sorted">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.sorted">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># if the chunk has allready been milled in the simulation</span></div>

<div class="viewcode-block" id="CamPathChunk.length">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.length">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># this is total length of this chunk.</span></div>

<div class="viewcode-block" id="CamPathChunk.zstart">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.zstart">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">zstart</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># this is stored for ramps mainly,</span></div>

        <span class="c1"># because they are added afterwards, but have to use layer info</span>
<div class="viewcode-block" id="CamPathChunk.zend">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.zend">[docs]</a>
        <span class="bp">self</span><span class="o">.</span><span class="n">zend</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1">#</span></div>


<div class="viewcode-block" id="CamPathChunk.update_poly">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.update_poly">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_poly</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly</span> <span class="o">=</span> <span class="n">sgeometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">poly</span> <span class="o">=</span> <span class="n">sgeometry</span><span class="o">.</span><span class="n">Polygon</span><span class="p">()</span></div>


<div class="viewcode-block" id="CamPathChunk.get_point">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.get_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>


<div class="viewcode-block" id="CamPathChunk.get_points">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.get_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>


<div class="viewcode-block" id="CamPathChunk.get_points_np">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.get_points_np">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_points_np</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span></div>


<div class="viewcode-block" id="CamPathChunk.set_points">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.set_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></div>


<div class="viewcode-block" id="CamPathChunk.count">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.count">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span></div>


<div class="viewcode-block" id="CamPathChunk.copy">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nchunk</span> <span class="o">=</span> <span class="n">CamPathChunk</span><span class="p">(</span>
            <span class="n">inpoints</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="n">startpoints</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">startpoints</span><span class="p">,</span>
            <span class="n">endpoints</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">,</span>
            <span class="n">rotations</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rotations</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">nchunk</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span>
        <span class="n">nchunk</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span>
        <span class="n">nchunk</span><span class="o">.</span><span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span>
        <span class="n">nchunk</span><span class="o">.</span><span class="n">sorted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted</span>
        <span class="n">nchunk</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
        <span class="k">return</span> <span class="n">nchunk</span></div>


<div class="viewcode-block" id="CamPathChunk.shift">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.shift">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">startpoints</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">startpoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span></div>


<div class="viewcode-block" id="CamPathChunk.set_z">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.set_z">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">if_bigger</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">if_bigger</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span> <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span></div>


<div class="viewcode-block" id="CamPathChunk.offset_z">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.offset_z">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">offset_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">z</span></div>


<div class="viewcode-block" id="CamPathChunk.flip_x">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.flip_x">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">flip_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_centre</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_centre</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="CamPathChunk.is_below_z">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.is_below_z">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_below_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">)</span></div>


<div class="viewcode-block" id="CamPathChunk.clamp_z">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.clamp_z">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clamp_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">z</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span></div>


<div class="viewcode-block" id="CamPathChunk.clamp_max_z">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.clamp_max_z">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clamp_max_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span></div>


<div class="viewcode-block" id="CamPathChunk.distance">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.distance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="n">dist_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dist_sq</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;MEANDER&quot;</span><span class="p">:</span>
                <span class="n">d1</span> <span class="o">=</span> <span class="n">distance_2d</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="n">distance_2d</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># if d2&lt;d1:</span>
                <span class="c1">#   ch.points.reverse()</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">distance_2d</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="CamPathChunk.distance_start">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.distance_start">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">distance_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">distance_2d</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="CamPathChunk.x_y_distance_within">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.x_y_distance_within">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">x_y_distance_within</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_poly</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">poly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">update_poly</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="o">.</span><span class="n">is_empty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">poly</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
            <span class="c1"># print(other.poly, cutoff)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="o">.</span><span class="n">dwithin</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">poly</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_internal_x_y_distance_to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cutoff</span></div>


    <span class="c1"># if cutoff is set, then the first distance &lt; cutoff is returned</span>
<div class="viewcode-block" id="CamPathChunk.x_y_distance_to">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.x_y_distance_to">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">x_y_distance_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_poly</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">poly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">update_poly</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="o">.</span><span class="n">is_empty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">poly</span><span class="o">.</span><span class="n">is_empty</span><span class="p">:</span>
            <span class="c1"># both polygons have &gt;2 points</span>
            <span class="c1"># simplify them if they aren&#39;t already, to speed up distance finding</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">simppoly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">simppoly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">poly</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="mf">0.0003</span><span class="p">)</span><span class="o">.</span><span class="n">boundary</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">simppoly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">other</span><span class="o">.</span><span class="n">simppoly</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">poly</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="mf">0.0003</span><span class="p">)</span><span class="o">.</span><span class="n">boundary</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">simppoly</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">simppoly</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># this is the old method, preferably should be replaced in most cases except parallel</span>
            <span class="c1"># where this method works probably faster.</span>
            <span class="c1"># print(&#39;warning, sorting will be slow due to bad parenting in parentChildDist&#39;)</span>
            <span class="k">return</span> <span class="n">_internal_x_y_distance_to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span></div>


<div class="viewcode-block" id="CamPathChunk.adapt_distance">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.adapt_distance">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">adapt_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
        <span class="c1"># reorders chunk so that it starts at the closest point to pos.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="n">dist_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">point_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist_sq</span><span class="p">)</span>
            <span class="n">new_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">point_idx</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:</span> <span class="n">point_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">new_points</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;MEANDER&quot;</span><span class="p">:</span>
                <span class="n">d1</span> <span class="o">=</span> <span class="n">distance_2d</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d2</span> <span class="o">=</span> <span class="n">distance_2d</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">d2</span> <span class="o">&lt;</span> <span class="n">d1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="CamPathChunk.get_next_closest">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.get_next_closest">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_next_closest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="c1"># finds closest chunk that can be milled, when inside sorting hierarchy.</span>
        <span class="n">mind</span> <span class="o">=</span> <span class="mi">100000000000</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cango</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">closest</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">testlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">testlist</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="n">tested</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tested</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">testlist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">chtest</span> <span class="o">=</span> <span class="n">testlist</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">chtest</span><span class="o">.</span><span class="n">sorted</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cango</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">cango</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">chtest</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">child</span><span class="o">.</span><span class="n">sorted</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tested</span><span class="p">:</span>
                            <span class="n">testlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                            <span class="n">tested</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                        <span class="n">cango</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="n">cango</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">chtest</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">mind</span><span class="p">:</span>
                        <span class="n">ch</span> <span class="o">=</span> <span class="n">chtest</span>
                        <span class="n">mind</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">if</span> <span class="n">ch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># print(&#39;found some&#39;)</span>
            <span class="k">return</span> <span class="n">ch</span>
        <span class="c1"># print(&#39;returning none&#39;)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="CamPathChunk.get_length">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.get_length">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># computes length of the chunk - in 3d</span>

        <span class="n">point_differences</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">point_differences</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span></div>


<div class="viewcode-block" id="CamPathChunk.reverse">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.reverse">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span></div>


<div class="viewcode-block" id="CamPathChunk.pop">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.pop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING: Popping from Chunk Is Slow&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">startpoints</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="CamPathChunk.dedupe_points">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.dedupe_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dedupe_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">keep_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">keep_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">diff_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">keep_points</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">diff_points</span> <span class="o">&gt;</span> <span class="mf">0.000000001</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">keep_points</span><span class="p">,</span> <span class="p">:]</span></div>


<div class="viewcode-block" id="CamPathChunk.insert">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.insert">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">at_index</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">startpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">point</span><span class="p">,</span>
            <span class="n">startpoint</span><span class="o">=</span><span class="n">startpoint</span><span class="p">,</span>
            <span class="n">endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">,</span>
            <span class="n">rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span>
            <span class="n">at_index</span><span class="o">=</span><span class="n">at_index</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="CamPathChunk.append">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.append">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">startpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">at_index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">at_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">point</span><span class="p">])))</span>
            <span class="k">if</span> <span class="n">startpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">startpoint</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">endpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endpoint</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">at_index</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">point</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">at_index</span><span class="p">:])</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">startpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">startpoints</span><span class="p">[</span><span class="n">at_index</span><span class="p">:</span><span class="n">at_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">startpoint</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">endpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">at_index</span><span class="p">:</span><span class="n">at_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">endpoint</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">rotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotations</span><span class="p">[</span><span class="n">at_index</span><span class="p">:</span><span class="n">at_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">rotation</span><span class="p">]</span></div>


<div class="viewcode-block" id="CamPathChunk.extend">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.extend">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">startpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">at_index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">at_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">startpoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">startpoints</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">endpoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rotations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rotations</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">at_index</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">at_index</span><span class="p">:])</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">startpoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">startpoints</span><span class="p">[</span><span class="n">at_index</span><span class="p">:</span><span class="n">at_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">startpoints</span>
            <span class="k">if</span> <span class="n">endpoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">at_index</span><span class="p">:</span><span class="n">at_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">endpoints</span>
            <span class="k">if</span> <span class="n">rotations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rotations</span><span class="p">[</span><span class="n">at_index</span><span class="p">:</span><span class="n">at_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">rotations</span></div>


<div class="viewcode-block" id="CamPathChunk.clip_points">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.clip_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clip_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minx</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxy</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove Any Points Outside This Range&quot;&quot;&quot;</span>
        <span class="n">included_values</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">minx</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">maxx</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">maxy</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">maxy</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">included_values</span><span class="p">]</span></div>


<div class="viewcode-block" id="CamPathChunk.ramp_contour">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.ramp_contour">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ramp_contour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zstart</span><span class="p">,</span> <span class="n">zend</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
        <span class="n">stepdown</span> <span class="o">=</span> <span class="n">zstart</span> <span class="o">-</span> <span class="n">zend</span>
        <span class="n">chunk_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">estlength</span> <span class="o">=</span> <span class="p">(</span><span class="n">zstart</span> <span class="o">-</span> <span class="n">zend</span><span class="p">)</span> <span class="o">/</span> <span class="n">tan</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">ramp_in_angle</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_length</span><span class="p">()</span>
        <span class="n">ramplength</span> <span class="o">=</span> <span class="n">estlength</span>  <span class="c1"># min(ch.length,estlength)</span>
        <span class="n">ltraveled</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">endpoint</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># z=zstart</span>
        <span class="n">znew</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">rounds</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># for counting if ramping makes more layers</span>
        <span class="k">while</span> <span class="n">endpoint</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">znew</span> <span class="o">==</span> <span class="n">zend</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>  <span class="c1">#</span>
            <span class="c1"># for i,s in enumerate(ch.points):</span>
            <span class="c1"># print(i, znew, zend, len(ch.points))</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">ltraveled</span> <span class="o">+=</span> <span class="n">distance_2d</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">ltraveled</span> <span class="o">/</span> <span class="n">ramplength</span>
            <span class="k">elif</span> <span class="n">rounds</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ltraveled</span> <span class="o">+=</span> <span class="n">distance_2d</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">ltraveled</span> <span class="o">/</span> <span class="n">ramplength</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">znew</span> <span class="o">=</span> <span class="n">zstart</span> <span class="o">-</span> <span class="n">stepdown</span> <span class="o">*</span> <span class="n">ratio</span>
            <span class="k">if</span> <span class="n">znew</span> <span class="o">&lt;=</span> <span class="n">zend</span><span class="p">:</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="n">zend</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="n">znew</span><span class="p">)</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">chunk_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">znew</span><span class="p">))</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">ratio</span> <span class="o">*</span> <span class="p">(</span><span class="n">v2</span> <span class="o">-</span> <span class="n">v1</span><span class="p">)</span>
                <span class="n">chunk_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)))</span>

                <span class="k">if</span> <span class="n">zend</span> <span class="o">==</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span> <span class="ow">and</span> <span class="n">endpoint</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
                    <span class="n">endpoint</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">endpoint</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
                        <span class="n">endpoint</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># print(endpoint,len(ch.points))</span>
            <span class="c1"># else:</span>
            <span class="n">znew</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">znew</span><span class="p">,</span> <span class="n">zend</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">chunk_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">znew</span><span class="p">))</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">znew</span>
            <span class="k">if</span> <span class="n">endpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">rounds</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># if not o.use_layers:</span>
        <span class="c1"># endpoint=0</span>
        <span class="k">if</span> <span class="n">endpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># append final contour on the bottom z level</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">endpoint</span>
            <span class="n">started</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># print(&#39;finaliz&#39;)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">endpoint</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">started</span><span class="p">:</span>
                <span class="n">started</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">chunk_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="c1"># print(i,endpoint)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># ramp out</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">ramp_out</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">use_layers</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">first_down</span> <span class="ow">or</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">first_down</span> <span class="ow">and</span> <span class="n">endpoint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">zend</span>
            <span class="c1"># i=endpoint</span>

            <span class="k">while</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">o</span><span class="o">.</span><span class="n">max_z</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i2</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">i2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i2</span><span class="p">]</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">distance_2d</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
                <span class="n">znew</span> <span class="o">=</span> <span class="n">z</span> <span class="o">+</span> <span class="n">tan</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">ramp_out_angle</span><span class="p">)</span> <span class="o">*</span> <span class="n">l</span>
                <span class="k">if</span> <span class="n">znew</span> <span class="o">&gt;</span> <span class="n">o</span><span class="o">.</span><span class="n">max_z</span><span class="p">:</span>
                    <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">max_z</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="n">znew</span><span class="p">)</span>
                    <span class="n">v1</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">chunk_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">v2</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">znew</span><span class="p">))</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">ratio</span> <span class="o">*</span> <span class="p">(</span><span class="n">v2</span> <span class="o">-</span> <span class="n">v1</span><span class="p">)</span>
                    <span class="n">chunk_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">chunk_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">znew</span><span class="p">))</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">znew</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># TODO: convert to numpy properly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chunk_points</span><span class="p">)</span></div>


<div class="viewcode-block" id="CamPathChunk.ramp_zig_zag">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.ramp_zig_zag">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ramp_zig_zag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">zstart</span><span class="p">,</span> <span class="n">zend</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
        <span class="c1"># TODO: convert to numpy properly</span>
        <span class="k">if</span> <span class="n">zend</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">chunk_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># print(zstart,zend)</span>
        <span class="k">if</span> <span class="n">zend</span> <span class="o">&lt;</span> <span class="n">zstart</span><span class="p">:</span>  <span class="c1"># this check here is only for stupid setup,</span>
            <span class="c1"># when the chunks lie actually above operation start z.</span>

            <span class="n">stepdown</span> <span class="o">=</span> <span class="n">zstart</span> <span class="o">-</span> <span class="n">zend</span>

            <span class="n">estlength</span> <span class="o">=</span> <span class="p">(</span><span class="n">zstart</span> <span class="o">-</span> <span class="n">zend</span><span class="p">)</span> <span class="o">/</span> <span class="n">tan</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">ramp_in_angle</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_length</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># for single point chunks..</span>
                <span class="n">ramplength</span> <span class="o">=</span> <span class="n">estlength</span>
                <span class="n">zigzaglength</span> <span class="o">=</span> <span class="n">ramplength</span> <span class="o">/</span> <span class="mf">2.000</span>
                <span class="n">turns</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Turns </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">turns</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">zigzaglength</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">:</span>
                    <span class="n">turns</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">zigzaglength</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
                    <span class="n">ramplength</span> <span class="o">=</span> <span class="n">turns</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">*</span> <span class="mf">2.0</span>
                    <span class="n">zigzaglength</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
                    <span class="n">ramppoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">zigzagtraveled</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="n">haspoints</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">ramppoints</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">])]</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="ow">not</span> <span class="n">haspoints</span><span class="p">:</span>
                        <span class="c1"># print(i,zigzaglength,zigzagtraveled)</span>
                        <span class="n">p1</span> <span class="o">=</span> <span class="n">ramppoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">distance_2d</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
                        <span class="n">zigzagtraveled</span> <span class="o">+=</span> <span class="n">d</span>
                        <span class="k">if</span> <span class="n">zigzagtraveled</span> <span class="o">&gt;=</span> <span class="n">zigzaglength</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
                            <span class="n">ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">zigzagtraveled</span> <span class="o">-</span> <span class="n">zigzaglength</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
                            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">points</span>
                            <span class="p">):</span>  <span class="c1"># this condition is for a rare case of combined layers+bridges+ramps..</span>
                                <span class="n">ratio</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">ratio</span> <span class="o">*</span> <span class="p">(</span><span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span>
                            <span class="n">ramppoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                            <span class="n">haspoints</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ramppoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">negramppoints</span> <span class="o">=</span> <span class="n">ramppoints</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">negramppoints</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">ramppoints</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">negramppoints</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

                <span class="n">traveled</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">chunk_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                        <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">zstart</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">turns</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ramppoints</span><span class="p">)):</span>
                        <span class="n">p1</span> <span class="o">=</span> <span class="n">chunk_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">p2</span> <span class="o">=</span> <span class="n">ramppoints</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                        <span class="n">d</span> <span class="o">=</span> <span class="n">distance_2d</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
                        <span class="n">traveled</span> <span class="o">+=</span> <span class="n">d</span>
                        <span class="n">ratio</span> <span class="o">=</span> <span class="n">traveled</span> <span class="o">/</span> <span class="n">ramplength</span>
                        <span class="n">znew</span> <span class="o">=</span> <span class="n">zstart</span> <span class="o">-</span> <span class="n">stepdown</span> <span class="o">*</span> <span class="n">ratio</span>
                        <span class="c1"># max value here is so that it doesn&#39;t go</span>
                        <span class="n">chunk_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">znew</span><span class="p">)))</span>
                        <span class="c1"># below surface in the case of 3d paths</span>

                <span class="c1"># chunks = setChunksZ([ch],zend)</span>
                <span class="n">chunk_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

            <span class="c1">######################################</span>
            <span class="c1"># ramp out - this is the same thing, just on the other side..</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">ramp_out</span><span class="p">:</span>
                <span class="n">zstart</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">max_z</span>
                <span class="n">zend</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                <span class="c1"># again, sometimes a chunk could theoretically end above the starting level.</span>
                <span class="k">if</span> <span class="n">zend</span> <span class="o">&lt;</span> <span class="n">zstart</span><span class="p">:</span>
                    <span class="n">stepdown</span> <span class="o">=</span> <span class="n">zstart</span> <span class="o">-</span> <span class="n">zend</span>

                    <span class="n">estlength</span> <span class="o">=</span> <span class="p">(</span><span class="n">zstart</span> <span class="o">-</span> <span class="n">zend</span><span class="p">)</span> <span class="o">/</span> <span class="n">tan</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">ramp_out_angle</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_length</span><span class="p">()</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ramplength</span> <span class="o">=</span> <span class="n">estlength</span>
                        <span class="n">zigzaglength</span> <span class="o">=</span> <span class="n">ramplength</span> <span class="o">/</span> <span class="mf">2.000</span>
                        <span class="n">turns</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Turns </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">turns</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">zigzaglength</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">:</span>
                            <span class="n">turns</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">zigzaglength</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
                            <span class="n">ramplength</span> <span class="o">=</span> <span class="n">turns</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">*</span> <span class="mf">2.0</span>
                            <span class="n">zigzaglength</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">length</span>
                            <span class="n">ramppoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                            <span class="c1"># revert points here, we go the other way.</span>
                            <span class="n">ramppoints</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">zigzagtraveled</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="n">haspoints</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="n">ramppoints</span> <span class="o">=</span> <span class="p">[</span>
                                <span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                                <span class="p">)</span>
                            <span class="p">]</span>
                            <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span>
                            <span class="k">while</span> <span class="ow">not</span> <span class="n">haspoints</span><span class="p">:</span>
                                <span class="c1"># print(i,zigzaglength,zigzagtraveled)</span>
                                <span class="n">p1</span> <span class="o">=</span> <span class="n">ramppoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                <span class="n">d</span> <span class="o">=</span> <span class="n">distance_2d</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
                                <span class="n">zigzagtraveled</span> <span class="o">+=</span> <span class="n">d</span>
                                <span class="k">if</span> <span class="n">zigzagtraveled</span> <span class="o">&gt;=</span> <span class="n">zigzaglength</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
                                    <span class="n">ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">zigzagtraveled</span> <span class="o">-</span> <span class="n">zigzaglength</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
                                    <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">points</span>
                                    <span class="p">):</span>  <span class="c1"># this condition is for a rare case of</span>
                                        <span class="c1"># combined layers+bridges+ramps...</span>
                                        <span class="n">ratio</span> <span class="o">=</span> <span class="mi">1</span>
                                    <span class="c1"># print((ratio,zigzaglength))</span>
                                    <span class="n">v</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">ratio</span> <span class="o">*</span> <span class="p">(</span><span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span>
                                    <span class="n">ramppoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                                    <span class="n">haspoints</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="c1"># elif :</span>

                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">ramppoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
                                <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">negramppoints</span> <span class="o">=</span> <span class="n">ramppoints</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">negramppoints</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                        <span class="n">ramppoints</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">negramppoints</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

                        <span class="n">traveled</span> <span class="o">=</span> <span class="mf">0.0</span>
                        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">turns</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ramppoints</span><span class="p">)):</span>
                                <span class="n">p1</span> <span class="o">=</span> <span class="n">chunk_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                <span class="n">p2</span> <span class="o">=</span> <span class="n">ramppoints</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                                <span class="n">d</span> <span class="o">=</span> <span class="n">distance_2d</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
                                <span class="n">traveled</span> <span class="o">+=</span> <span class="n">d</span>
                                <span class="n">ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">traveled</span> <span class="o">/</span> <span class="n">ramplength</span><span class="p">)</span>
                                <span class="n">znew</span> <span class="o">=</span> <span class="n">zstart</span> <span class="o">-</span> <span class="n">stepdown</span> <span class="o">*</span> <span class="n">ratio</span>
                                <span class="n">chunk_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">znew</span><span class="p">)))</span>
                                <span class="c1"># max value here is so that it doesn&#39;t go below surface in the case of 3d paths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chunk_points</span><span class="p">)</span></div>


    <span class="c1">#  modify existing path start point</span>
<div class="viewcode-block" id="CamPathChunk.change_path_start">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.change_path_start">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">change_path_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">profile_start</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">newstart</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">profile_start</span>
            <span class="n">chunkamt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
            <span class="n">newstart</span> <span class="o">=</span> <span class="n">newstart</span> <span class="o">%</span> <span class="n">chunkamt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">newstart</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:</span><span class="n">newstart</span><span class="p">]))</span></div>


<div class="viewcode-block" id="CamPathChunk.break_path_for_leadin_leadout">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.break_path_for_leadin_leadout">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">break_path_for_leadin_leadout</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
        <span class="n">iradius</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">lead_in</span>
        <span class="n">oradius</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">lead_out</span>
        <span class="k">if</span> <span class="n">iradius</span> <span class="o">+</span> <span class="n">oradius</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">chunkamt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chunkamt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">apoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">bpoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">bmax</span> <span class="o">=</span> <span class="n">bpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">apoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bmay</span> <span class="o">=</span> <span class="n">bpoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">apoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">segmentLength</span> <span class="o">=</span> <span class="n">hypot</span><span class="p">(</span><span class="n">bmax</span><span class="p">,</span> <span class="n">bmay</span><span class="p">)</span>  <span class="c1"># find segment length</span>

                <span class="k">if</span> <span class="n">segmentLength</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span>
                    <span class="n">iradius</span><span class="p">,</span> <span class="n">oradius</span>
                <span class="p">):</span>  <span class="c1"># Be certain there is enough room for the leadin and leadiout</span>
                    <span class="c1"># add point on the line here</span>
                    <span class="c1"># average of the two x points to find center</span>
                    <span class="n">newpointx</span> <span class="o">=</span> <span class="p">(</span><span class="n">bpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">apoint</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="c1"># average of the two y points to find center</span>
                    <span class="n">newpointy</span> <span class="o">=</span> <span class="p">(</span><span class="n">bpoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">apoint</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">newpointx</span><span class="p">,</span> <span class="n">newpointy</span><span class="p">,</span> <span class="n">apoint</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]),</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:],</span>
                        <span class="p">)</span>
                    <span class="p">)</span></div>


<div class="viewcode-block" id="CamPathChunk.lead_contour">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.CamPathChunk.lead_contour">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">lead_contour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
        <span class="n">perimeterDirection</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># 1 is clockwise, 0 is CCW</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">spindle_rotation</span> <span class="o">==</span> <span class="s2">&quot;CW&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;CONVENTIONAL&quot;</span><span class="p">:</span>
                <span class="n">perimeterDirection</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>  <span class="c1"># if it is inside another parent</span>
            <span class="n">perimeterDirection</span> <span class="o">^=</span> <span class="mi">1</span>  <span class="c1"># toggle with a bitwise XOR</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Has Parent&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">perimeterDirection</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Path Direction is Clockwise&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Path Direction is Counter Clockwise&quot;</span><span class="p">)</span>
        <span class="n">iradius</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">lead_in</span>
        <span class="n">oradius</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">lead_out</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nextp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">rpoint</span> <span class="o">=</span> <span class="n">rotate_point_by_point</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">nextp</span><span class="p">,</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">rpoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">rpoint</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">la</span> <span class="o">=</span> <span class="n">hypot</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span>
        <span class="n">pvx</span> <span class="o">=</span> <span class="p">(</span><span class="n">iradius</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span> <span class="o">/</span> <span class="n">la</span> <span class="o">+</span> <span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># arc center(x)</span>
        <span class="n">pvy</span> <span class="o">=</span> <span class="p">(</span><span class="n">iradius</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span> <span class="o">/</span> <span class="n">la</span> <span class="o">+</span> <span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># arc center(y)</span>
        <span class="n">arc_c</span> <span class="o">=</span> <span class="p">[</span><span class="n">pvx</span><span class="p">,</span> <span class="n">pvy</span><span class="p">,</span> <span class="n">start</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

        <span class="c1"># TODO: this could easily be numpy</span>
        <span class="n">chunk_points</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># create a new cutting path</span>

        <span class="c1"># add lead in arc in the begining</span>
        <span class="k">if</span> <span class="nb">round</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">lead_in</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
                <span class="n">iangle</span> <span class="o">=</span> <span class="o">-</span><span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">15</span>
                <span class="n">arc_p</span> <span class="o">=</span> <span class="n">rotate_point_by_point</span><span class="p">(</span><span class="n">arc_c</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">iangle</span><span class="p">)</span>
                <span class="n">chunk_points</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">arc_p</span><span class="p">)</span>

        <span class="c1"># glue rest of the path to the arc</span>
        <span class="n">chunk_points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="c1"># for i in range(len(self.points)):</span>
        <span class="c1">#     chunk_points.append(self.points[i])</span>

        <span class="c1"># add lead out arc to the end</span>
        <span class="k">if</span> <span class="nb">round</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">lead_in</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">):</span>
                <span class="n">iangle</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">15</span>
                <span class="n">arc_p</span> <span class="o">=</span> <span class="n">rotate_point_by_point</span><span class="p">(</span><span class="n">arc_c</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">iangle</span><span class="p">)</span>
                <span class="n">chunk_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arc_p</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">chunk_points</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="chunks_coherency">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.chunks_coherency">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">chunks_coherency</span><span class="p">(</span><span class="n">chunks</span><span class="p">):</span>
    <span class="c1"># checks chunks for their stability, for pencil path.</span>
    <span class="c1"># it checks if the vectors direction doesn&#39;t jump too much too quickly,</span>
    <span class="c1"># if this happens it splits the chunk on such places,</span>
    <span class="c1"># too much jumps = deletion of the chunk. this is because otherwise the router has to slow down too often,</span>
    <span class="c1"># but also means that some parts detected by cavity algorithm won&#39;t be milled</span>
    <span class="n">nchunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">nchunk</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">()</span>

            <span class="c1"># doesn&#39;t check for 1 point chunks here, they shouldn&#39;t get here at all.</span>
            <span class="n">lastvec</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">Vector</span><span class="p">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="n">Vector</span><span class="p">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">lastvec</span><span class="p">,</span> <span class="n">vec</span><span class="p">)</span>
                <span class="c1"># print(angle,i)</span>
                <span class="k">if</span> <span class="n">angle</span> <span class="o">&gt;</span> <span class="mf">1.07</span><span class="p">:</span>  <span class="c1"># 60 degrees is maximum toleration for pencil paths.</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>  <span class="c1"># this is a testing threshold</span>
                        <span class="n">nchunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nchunk</span><span class="o">.</span><span class="n">to_chunk</span><span class="p">())</span>
                    <span class="n">nchunk</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">()</span>
                <span class="n">lastvec</span> <span class="o">=</span> <span class="n">vec</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>  <span class="c1"># this is a testing threshold</span>
                <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
                <span class="n">nchunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nchunk</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nchunks</span></div>



<div class="viewcode-block" id="limit_chunks">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.limit_chunks">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">limit_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>  <span class="c1"># TODO: this should at least add point on area border...</span>
    <span class="c1"># but shouldn&#39;t be needed at all at the first place...</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">use_limit_curve</span> <span class="ow">or</span> <span class="n">force</span><span class="p">:</span>
        <span class="n">nchunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
            <span class="n">prevsampled</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">nch</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">()</span>
            <span class="n">nch1</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">closed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
                <span class="n">sampled</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ambient</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">sgeometry</span><span class="o">.</span><span class="n">Point</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">sampled</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">nch</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">nch</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">closed</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">nchunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nch</span><span class="o">.</span><span class="n">to_chunk</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">nch1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">nch1</span> <span class="o">=</span> <span class="n">nchunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">nch</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">sampled</span><span class="p">:</span>
                    <span class="n">nch</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="n">prevsampled</span> <span class="o">=</span> <span class="n">sampled</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">nch</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>
                <span class="ow">and</span> <span class="n">closed</span>
                <span class="ow">and</span> <span class="n">ch</span><span class="o">.</span><span class="n">closed</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">):</span>
                <span class="n">nch</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">closed</span>
                <span class="ow">and</span> <span class="n">nch1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">nch</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">nch</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nch1</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">):</span>
                <span class="c1"># here adds beginning of closed chunk to the end, if the chunks were split during limiting</span>
                <span class="n">nch</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">nch1</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                <span class="n">nchunks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">nch1</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Joining&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nch</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nchunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nch</span><span class="o">.</span><span class="n">to_chunk</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">nchunks</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">chunks</span></div>



<div class="viewcode-block" id="mesh_from_curve_to_chunk">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.mesh_from_curve_to_chunk">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mesh_from_curve_to_chunk</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">data</span>
    <span class="c1"># print(&#39;detecting contours from curve&#39;)</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">()</span>
    <span class="n">ek</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">edge_keys</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ek</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1">#</span>
    <span class="n">dk</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">x</span>
    <span class="n">y</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">y</span>
    <span class="n">z</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">z</span>
    <span class="n">lastvi</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">vtotal</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
    <span class="n">perc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">progress</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing Curve - START - Vertices: </span><span class="si">{</span><span class="n">vtotal</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">vi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">co</span> <span class="o">=</span> <span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vi</span><span class="p">]</span><span class="o">.</span><span class="n">co</span> <span class="o">+</span> <span class="nb">object</span><span class="o">.</span><span class="n">location</span><span class="p">)</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dk</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">([(</span><span class="n">vi</span><span class="p">,</span> <span class="n">vi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span> <span class="ow">and</span> <span class="n">d</span><span class="p">[(</span><span class="n">vi</span><span class="p">,</span> <span class="n">vi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">co</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">co</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="p">(</span><span class="n">dk</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">([(</span><span class="n">vi</span><span class="p">,</span> <span class="n">lastvi</span><span class="p">)]))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dk</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">([(</span><span class="n">lastvi</span><span class="p">,</span> <span class="n">vi</span><span class="p">)]))</span>
            <span class="p">):</span>  <span class="c1"># this was looping chunks of length of only 2 points...</span>
                <span class="c1"># print(&#39;itis&#39;)</span>

                <span class="n">chunk</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">lastvi</span><span class="p">]</span><span class="o">.</span><span class="n">co</span> <span class="o">+</span> <span class="nb">object</span><span class="o">.</span><span class="n">location</span><span class="p">)</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())</span>
                <span class="c1"># add first point to end#originally the z was mesh.vertices[lastvi].co.z+z</span>
            <span class="n">lastvi</span> <span class="o">=</span> <span class="n">vi</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">.</span><span class="n">to_chunk</span><span class="p">()</span>
            <span class="n">chunk</span><span class="o">.</span><span class="n">dedupe_points</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">chunk</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># dump single point chunks</span>
                <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">()</span>

    <span class="n">progress</span><span class="p">(</span><span class="s2">&quot;Processing Curve - FINISHED&quot;</span><span class="p">)</span>

    <span class="n">vi</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vi</span><span class="p">]</span><span class="o">.</span><span class="n">co</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vi</span><span class="p">]</span><span class="o">.</span><span class="n">co</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vi</span><span class="p">]</span><span class="o">.</span><span class="n">co</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dk</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">([(</span><span class="n">vi</span><span class="p">,</span> <span class="n">lastvi</span><span class="p">)]))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="n">dk</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">([(</span><span class="n">lastvi</span><span class="p">,</span> <span class="n">vi</span><span class="p">)])):</span>
        <span class="n">chunk</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">lastvi</span><span class="p">]</span><span class="o">.</span><span class="n">co</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">lastvi</span><span class="p">]</span><span class="o">.</span><span class="n">co</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span>
                <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">lastvi</span><span class="p">]</span><span class="o">.</span><span class="n">co</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">z</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="n">chunk</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">.</span><span class="n">to_chunk</span><span class="p">()</span>
    <span class="n">chunk</span><span class="o">.</span><span class="n">dedupe_points</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">chunk</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># dump single point chunks</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chunks</span></div>



<div class="viewcode-block" id="curve_to_chunks">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.curve_to_chunks">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">curve_to_chunks</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">use_modifiers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">co</span> <span class="o">=</span> <span class="n">mesh_from_curve</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">use_modifiers</span><span class="p">)</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="n">mesh_from_curve_to_chunk</span><span class="p">(</span><span class="n">co</span><span class="p">)</span>

    <span class="n">co</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span>

    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">select_all</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s2">&quot;DESELECT&quot;</span><span class="p">)</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">co</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">select_set</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">chunks</span></div>



<div class="viewcode-block" id="shapely_to_chunks">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.shapely_to_chunks">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">shapely_to_chunks</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">zlevel</span><span class="p">):</span>  <span class="c1">#</span>
    <span class="n">chunk_builders</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># p=sortContours(p)</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="n">shapely_to_coordinates</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
        <span class="c1"># progress(p[i])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">has_z</span><span class="p">:</span>
                    <span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">zlevel</span><span class="p">))</span>

            <span class="n">chunk_builders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">chunk_builders</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>  <span class="c1"># this is for smaller shapes first.</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">to_chunk</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunk_builders</span><span class="p">]</span></div>



<div class="viewcode-block" id="curve_to_shapely">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.curve_to_shapely">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">curve_to_shapely</span><span class="p">(</span><span class="n">cob</span><span class="p">,</span> <span class="n">use_modifiers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a curve object to Shapely polygons.</span>

<span class="sd">    This function takes a curve object and converts it into a list of</span>
<span class="sd">    Shapely polygons. It first breaks the curve into chunks and then</span>
<span class="sd">    transforms those chunks into Shapely-compatible polygon representations.</span>
<span class="sd">    The `use_modifiers` parameter allows for additional processing of the</span>
<span class="sd">    curve before conversion, depending on the specific requirements of the</span>
<span class="sd">    application.</span>

<span class="sd">    Args:</span>
<span class="sd">        cob: The curve object to be converted.</span>
<span class="sd">        use_modifiers (bool): A flag indicating whether to apply modifiers</span>
<span class="sd">            during the conversion process. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of Shapely polygons created from the curve object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">chunks</span> <span class="o">=</span> <span class="n">curve_to_chunks</span><span class="p">(</span><span class="n">cob</span><span class="p">,</span> <span class="n">use_modifiers</span><span class="p">)</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="n">chunks_to_shapely</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">polys</span></div>



<div class="viewcode-block" id="sample_chunks_n_axis">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.sample_chunks_n_axis">[docs]</a>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">sample_chunks_n_axis</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">pathSamples</span><span class="p">,</span> <span class="n">layers</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample chunks along a specified axis based on provided paths and layers.</span>

<span class="sd">    This function processes a set of path samples and organizes them into</span>
<span class="sd">    chunks according to specified layers. It prepares the collision world if</span>
<span class="sd">    necessary, updates the cutter&#39;s rotation based on the path samples, and</span>
<span class="sd">    handles the sampling of points along the paths. The function also</span>
<span class="sd">    manages the relationships between the sampled points and their</span>
<span class="sd">    respective layers, ensuring that the correct points are added to each</span>
<span class="sd">    chunk. The resulting chunks can be used for further processing in a 3D</span>
<span class="sd">    environment.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): An object containing properties such as min/max coordinates,</span>
<span class="sd">            cutter shape, and other relevant parameters.</span>
<span class="sd">        pathSamples (list): A list of path samples, each containing start points,</span>
<span class="sd">            end points, and rotations.</span>
<span class="sd">        layers (list): A list of layer definitions that specify the boundaries</span>
<span class="sd">            for sampling.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of sampled chunks organized by layers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">minz</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">maxz</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span>

    <span class="c1"># prepare collision world</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">update_bullet_collision_tag</span><span class="p">:</span>
        <span class="n">prepare_bullet_collision</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="c1"># print(&#39;getting ambient&#39;)</span>
        <span class="n">get_ambient</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="n">o</span><span class="o">.</span><span class="n">update_bullet_collision_tag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># print (o.ambient)</span>
    <span class="n">cutter</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">cutter_shape</span>
    <span class="n">cutterdepth</span> <span class="o">=</span> <span class="n">cutter</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">z</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sampling Paths&quot;</span><span class="p">)</span>

    <span class="n">totlen</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># total length of all chunks, to estimate sampling time.</span>
    <span class="k">for</span> <span class="n">chs</span> <span class="ow">in</span> <span class="n">pathSamples</span><span class="p">:</span>
        <span class="n">totlen</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chs</span><span class="o">.</span><span class="n">startpoints</span><span class="p">)</span>
    <span class="n">layerchunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">minz</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">min_z</span>
    <span class="n">layeractivechunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lastrunchunks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
        <span class="n">layerchunks</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="n">layeractivechunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CamPathChunkBuilder</span><span class="p">([]))</span>
        <span class="n">lastrunchunks</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">last_percent</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">lastz</span> <span class="o">=</span> <span class="n">minz</span>
    <span class="k">for</span> <span class="n">patternchunk</span> <span class="ow">in</span> <span class="n">pathSamples</span><span class="p">:</span>
        <span class="c1"># print (patternchunk.endpoints)</span>
        <span class="n">thisrunchunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">thisrunchunks</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="n">lastlayer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">currentlayer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">lastsample</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># threads_count=4</span>
        <span class="n">lastrotation</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># for t in range(0,threads):</span>
        <span class="c1"># print(len(patternchunk.startpoints),len( patternchunk.endpoints))</span>
        <span class="n">spl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">patternchunk</span><span class="o">.</span><span class="n">startpoints</span><span class="p">)</span>
        <span class="c1"># ,startp in enumerate(patternchunk.startpoints):</span>
        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">spl</span><span class="p">):</span>
            <span class="c1"># #TODO: seems we are writing into the source chunk ,</span>
            <span class="c1">#  and that is why we need to write endpoints everywhere too?</span>

            <span class="n">percent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">totlen</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">percent</span> <span class="o">!=</span> <span class="n">last_percent</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">progress_async</span><span class="p">(</span><span class="s2">&quot;Sampling Paths&quot;</span><span class="p">,</span> <span class="n">percent</span><span class="p">)</span>
                <span class="n">last_percent</span> <span class="o">=</span> <span class="n">percent</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">sampled</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># print(si)</span>

            <span class="c1"># get the vector to sample</span>
            <span class="n">startp</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">patternchunk</span><span class="o">.</span><span class="n">startpoints</span><span class="p">[</span><span class="n">si</span><span class="p">])</span>
            <span class="n">endp</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">patternchunk</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">si</span><span class="p">])</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="n">patternchunk</span><span class="o">.</span><span class="n">rotations</span><span class="p">[</span><span class="n">si</span><span class="p">]</span>
            <span class="n">sweepvect</span> <span class="o">=</span> <span class="n">endp</span> <span class="o">-</span> <span class="n">startp</span>
            <span class="n">sweepvect</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
            <span class="c1"># sampling</span>
            <span class="k">if</span> <span class="n">rotation</span> <span class="o">!=</span> <span class="n">lastrotation</span><span class="p">:</span>
                <span class="n">cutter</span><span class="o">.</span><span class="n">rotation_euler</span> <span class="o">=</span> <span class="n">rotation</span>
                <span class="c1"># cutter.rotation_euler.x=-cutter.rotation_euler.x</span>
                <span class="c1"># print(rotation)</span>

                <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">cutter_type</span> <span class="o">==</span> <span class="s2">&quot;VCARVE&quot;</span><span class="p">:</span>  <span class="c1"># Bullet cone is always pointing Up Z in the object</span>
                    <span class="n">cutter</span><span class="o">.</span><span class="n">rotation_euler</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">pi</span>
                <span class="n">cutter</span><span class="o">.</span><span class="n">update_tag</span><span class="p">()</span>
                <span class="c1"># this has to be :( it resets the rigidbody world.</span>
                <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">frame_set</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># No other way to update it probably now :(</span>
                <span class="c1"># actually 2 frame jumps are needed.</span>
                <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">frame_set</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">frame_set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">newsample</span> <span class="o">=</span> <span class="n">get_sample_bullet_n_axis</span><span class="p">(</span><span class="n">cutter</span><span class="p">,</span> <span class="n">startp</span><span class="p">,</span> <span class="n">endp</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">cutterdepth</span><span class="p">)</span>

            <span class="c1"># print(&#39;totok&#39;,startp,endp,rotation,newsample)</span>
            <span class="c1">################################</span>
            <span class="c1"># handling samples</span>
            <span class="c1">############################################</span>
            <span class="c1"># this is weird, but will leave it this way now.. just prototyping here.</span>
            <span class="k">if</span> <span class="n">newsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sampled</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># TODO: why was this here?</span>
                <span class="n">newsample</span> <span class="o">=</span> <span class="n">startp</span>
                <span class="n">sampled</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># print(newsample)</span>

            <span class="c1"># elif o.ambient_behaviour==&#39;ALL&#39; and not o.inverse:#handle ambient here</span>
            <span class="c1"># newsample=(x,y,minz)</span>
            <span class="k">if</span> <span class="n">sampled</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
                    <span class="n">terminatechunk</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">ch</span> <span class="o">=</span> <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                    <span class="c1"># print(i,l)</span>
                    <span class="c1"># print(l[1],l[0])</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">startp</span> <span class="o">-</span> <span class="n">newsample</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="o">-</span><span class="n">v</span><span class="o">.</span><span class="n">length</span>

                    <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">lastlayer</span> <span class="o">=</span> <span class="n">currentlayer</span>
                        <span class="n">currentlayer</span> <span class="o">=</span> <span class="n">i</span>

                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">lastsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                            <span class="ow">and</span> <span class="n">lastlayer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                            <span class="ow">and</span> <span class="n">currentlayer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                            <span class="ow">and</span> <span class="n">lastlayer</span> <span class="o">!=</span> <span class="n">currentlayer</span>
                        <span class="p">):</span>  <span class="c1"># sampling for sorted paths in layers-</span>
                            <span class="c1"># to go to the border of the sampled layer at least...</span>
                            <span class="c1"># there was a bug here, but should be fixed.</span>
                            <span class="k">if</span> <span class="n">currentlayer</span> <span class="o">&lt;</span> <span class="n">lastlayer</span><span class="p">:</span>
                                <span class="n">growing</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">currentlayer</span><span class="p">,</span> <span class="n">lastlayer</span><span class="p">)</span>
                                <span class="n">spliti</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">lastlayer</span><span class="p">,</span> <span class="n">currentlayer</span><span class="p">)</span>
                                <span class="n">growing</span> <span class="o">=</span> <span class="kc">False</span>
                                <span class="n">spliti</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="c1"># print(r)</span>
                            <span class="n">li</span> <span class="o">=</span> <span class="mi">0</span>

                            <span class="k">for</span> <span class="n">ls</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                                <span class="n">splitdistance</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="n">ls</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

                                <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">splitdistance</span> <span class="o">-</span> <span class="n">lastdistance</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">distance</span> <span class="o">-</span> <span class="n">lastdistance</span><span class="p">)</span>
                                <span class="c1"># print(ratio)</span>
                                <span class="n">betweensample</span> <span class="o">=</span> <span class="n">lastsample</span> <span class="o">+</span> <span class="p">(</span><span class="n">newsample</span> <span class="o">-</span> <span class="n">lastsample</span><span class="p">)</span> <span class="o">*</span> <span class="n">ratio</span>
                                <span class="c1"># this probably doesn&#39;t work at all!!!! check this algoritm&gt;</span>
                                <span class="n">betweenrotation</span> <span class="o">=</span> <span class="n">tuple_add</span><span class="p">(</span>
                                    <span class="n">lastrotation</span><span class="p">,</span>
                                    <span class="n">tuple_multiply</span><span class="p">(</span><span class="n">tuple_subtract</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">lastrotation</span><span class="p">),</span> <span class="n">ratio</span><span class="p">),</span>
                                <span class="p">)</span>
                                <span class="c1"># startpoint = retract point, it has to be always available...</span>
                                <span class="n">betweenstartpoint</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">laststartpoint</span> <span class="o">+</span> <span class="p">(</span><span class="n">startp</span> <span class="o">-</span> <span class="n">laststartpoint</span><span class="p">)</span> <span class="o">*</span> <span class="n">ratio</span>
                                <span class="p">)</span>
                                <span class="c1"># here, we need to have also possible endpoints always..</span>
                                <span class="n">betweenendpoint</span> <span class="o">=</span> <span class="n">lastendpoint</span> <span class="o">+</span> <span class="p">(</span><span class="n">endp</span> <span class="o">-</span> <span class="n">lastendpoint</span><span class="p">)</span> <span class="o">*</span> <span class="n">ratio</span>
                                <span class="k">if</span> <span class="n">growing</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">li</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweensample</span><span class="p">)</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweenrotation</span><span class="p">)</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                                            <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweenstartpoint</span>
                                        <span class="p">)</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweenendpoint</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweensample</span><span class="p">)</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenrotation</span><span class="p">)</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenstartpoint</span><span class="p">)</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenendpoint</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweensample</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenrotation</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenstartpoint</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenendpoint</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweensample</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweenrotation</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweenstartpoint</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweenendpoint</span><span class="p">)</span>

                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweensample</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenrotation</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenstartpoint</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenendpoint</span><span class="p">)</span>

                                <span class="c1"># layeractivechunks[ls+1].points.insert(0,betweensample)</span>
                                <span class="n">li</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="c1"># this chunk is terminated, and allready in layerchunks /</span>

                        <span class="c1"># ch.points.append(betweensample)#</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newsample</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">startp</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endp</span><span class="p">)</span>
                        <span class="n">lastdistance</span> <span class="o">=</span> <span class="n">distance</span>

                    <span class="k">elif</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">sweepvect</span> <span class="o">*</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">startp</span> <span class="o">-</span> <span class="n">v</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">startp</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endp</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">:</span>  <span class="c1"># retract to original track</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">startp</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">startp</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endp</span><span class="p">)</span>

            <span class="n">lastsample</span> <span class="o">=</span> <span class="n">newsample</span>
            <span class="n">lastrotation</span> <span class="o">=</span> <span class="n">rotation</span>
            <span class="n">laststartpoint</span> <span class="o">=</span> <span class="n">startp</span>
            <span class="n">lastendpoint</span> <span class="o">=</span> <span class="n">endp</span>

        <span class="c1"># convert everything to actual chunks</span>
        <span class="c1"># rather than chunkBuilders</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
            <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">to_chunk</span><span class="p">()</span> <span class="k">if</span> <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                <span class="n">thisrunchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">([])</span>

            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;PARALLEL&quot;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;CROSS&quot;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;OUTLINEFILL&quot;</span><span class="p">:</span>
                <span class="n">parent_child_distance</span><span class="p">(</span><span class="n">thisrunchunks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lastrunchunks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">o</span><span class="p">)</span>

        <span class="n">lastrunchunks</span> <span class="o">=</span> <span class="n">thisrunchunks</span>

    <span class="c1"># print(len(layerchunks[i]))</span>

    <span class="n">progress</span><span class="p">(</span><span class="s2">&quot;Checking Relations Between Paths&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;#this algorithm should also work for n-axis, but now is &quot;sleeping&quot;</span>
<span class="sd">    if (o.strategy==&#39;PARALLEL&#39; or o.strategy==&#39;CROSS&#39;):</span>
<span class="sd">        if len(layers)&gt;1:# sorting help so that upper layers go first always</span>
<span class="sd">            for i in range(0,len(layers)-1):</span>
<span class="sd">                #print(&#39;layerstuff parenting&#39;)</span>
<span class="sd">                parentChild(layerchunks[i+1],layerchunks[i],o)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">chunks</span></div>



<div class="viewcode-block" id="sample_path_low">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.sample_path_low">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sample_path_low</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">ch1</span><span class="p">,</span> <span class="n">ch2</span><span class="p">,</span> <span class="n">dosample</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a sample path between two channels.</span>

<span class="sd">    This function computes a series of points that form a path between two</span>
<span class="sd">    given channels. It calculates the direction vector from the end of the</span>
<span class="sd">    first channel to the start of the second channel and generates points</span>
<span class="sd">    along this vector up to a specified distance. If sampling is enabled, it</span>
<span class="sd">    modifies the z-coordinate of the generated points based on the cutter</span>
<span class="sd">    shape or image sampling, ensuring that the path accounts for any</span>
<span class="sd">    obstacles or features in the environment.</span>

<span class="sd">    Args:</span>
<span class="sd">        o: An object containing optimization parameters and properties related to</span>
<span class="sd">            the path generation.</span>
<span class="sd">        ch1: The first channel object, which provides a point for the starting</span>
<span class="sd">            location of the path.</span>
<span class="sd">        ch2: The second channel object, which provides a point for the ending</span>
<span class="sd">            location of the path.</span>
<span class="sd">        dosample (bool): A flag indicating whether to perform sampling along the generated path.</span>

<span class="sd">    Returns:</span>
<span class="sd">        CamPathChunk: An object representing the generated path points.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">v1</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">ch1</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">ch2</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">-</span> <span class="n">v1</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">length</span>
    <span class="n">v</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

    <span class="n">vref</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">bpath_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">vref</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">vref</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">distance_along_paths</span> <span class="o">*</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">vref</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">vref</span>
            <span class="n">bpath_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
    <span class="c1"># print(&#39;between path&#39;)</span>
    <span class="c1"># print(len(bpath))</span>
    <span class="n">pixsize</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span>
    <span class="k">if</span> <span class="n">dosample</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">update_bullet_collision_tag</span><span class="p">:</span>
                    <span class="n">prepare_bullet_collision</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                    <span class="n">o</span><span class="o">.</span><span class="n">update_bullet_collision_tag</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">cutterdepth</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">cutter_shape</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">z</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">bpath_points</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">get_sample_bullet</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">cutter_shape</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cutterdepth</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min_z</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">bpath_points</span><span class="p">:</span>
                    <span class="n">xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">pixsize</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span> <span class="o">+</span> <span class="n">pixsize</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># -m</span>
                    <span class="n">ys</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="n">pixsize</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span> <span class="o">+</span> <span class="n">pixsize</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># -m</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">get_sample_image</span><span class="p">((</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">),</span> <span class="n">o</span><span class="o">.</span><span class="n">offset_image</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min_z</span><span class="p">)</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">skin</span>
                    <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span>
    <span class="k">return</span> <span class="n">CamPathChunk</span><span class="p">(</span><span class="n">bpath_points</span><span class="p">)</span></div>



<div class="viewcode-block" id="polygon_boolean">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.polygon_boolean">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">polygon_boolean</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">boolean_type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform a boolean operation on selected polygons.</span>

<span class="sd">    This function takes the active object and applies a specified boolean</span>
<span class="sd">    operation (UNION, DIFFERENCE, or INTERSECT) with respect to other</span>
<span class="sd">    selected objects in the Blender context. It first converts the polygons</span>
<span class="sd">    of the active object and the selected objects into a Shapely</span>
<span class="sd">    MultiPolygon. Depending on the boolean type specified, it performs the</span>
<span class="sd">    corresponding boolean operation and then converts the result back into a</span>
<span class="sd">    Blender curve.</span>

<span class="sd">    Args:</span>
<span class="sd">        context (bpy.context): The Blender context containing scene and object data.</span>
<span class="sd">        boolean_type (str): The type of boolean operation to perform.</span>
<span class="sd">            Must be one of &#39;UNION&#39;, &#39;DIFFERENCE&#39;, or &#39;INTERSECT&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary indicating the operation result, typically {&#39;FINISHED&#39;}.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span>
    <span class="n">obs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ob1</span> <span class="ow">in</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">selected_objects</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ob1</span> <span class="o">!=</span> <span class="n">ob</span><span class="p">:</span>
            <span class="n">obs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ob1</span><span class="p">)</span>
    <span class="n">plist</span> <span class="o">=</span> <span class="n">curve_to_shapely</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">MultiPolygon</span><span class="p">(</span><span class="n">plist</span><span class="p">)</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obs</span><span class="p">:</span>
        <span class="n">plist</span> <span class="o">=</span> <span class="n">curve_to_shapely</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">MultiPolygon</span><span class="p">(</span><span class="n">plist</span><span class="p">)</span>
        <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
    <span class="c1"># print(polys)</span>
    <span class="k">if</span> <span class="n">boolean_type</span> <span class="o">==</span> <span class="s2">&quot;UNION&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">boolean_type</span> <span class="o">==</span> <span class="s2">&quot;DIFFERENCE&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">boolean_type</span> <span class="o">==</span> <span class="s2">&quot;INTERSECT&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>

    <span class="n">shapely_to_curve</span><span class="p">(</span><span class="s2">&quot;boolean&quot;</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">ob</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;FINISHED&quot;</span><span class="p">}</span></div>



<div class="viewcode-block" id="polygon_convex_hull">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.polygon_convex_hull">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">polygon_convex_hull</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the convex hull of a polygon from the given context.</span>

<span class="sd">    This function duplicates the current object, joins it, and converts it</span>
<span class="sd">    into a 3D mesh. It then extracts the X and Y coordinates of the vertices</span>
<span class="sd">    to create a MultiPoint data structure using Shapely. Finally, it</span>
<span class="sd">    computes the convex hull of these points and converts the result back</span>
<span class="sd">    into a curve named &#39;ConvexHull&#39;. Temporary objects created during this</span>
<span class="sd">    process are deleted to maintain a clean workspace.</span>

<span class="sd">    Args:</span>
<span class="sd">        context: The context in which the operation is performed, typically</span>
<span class="sd">            related to Blender&#39;s current state.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary indicating the operation&#39;s completion status.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">coords</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="s2">&quot;3D&quot;</span>  <span class="c1"># force curve to be a 3D curve</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">transform_apply</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_tmp&quot;</span>

    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="s2">&quot;MESH&quot;</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">view_layer</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">active</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>  <span class="c1"># extract X,Y coordinates from the vertices data</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">co</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">co</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="n">select_multiple</span><span class="p">(</span><span class="s2">&quot;_tmp&quot;</span><span class="p">)</span>  <span class="c1"># delete temporary mesh</span>
    <span class="n">select_multiple</span><span class="p">(</span><span class="s2">&quot;ConvexHull&quot;</span><span class="p">)</span>  <span class="c1"># delete old hull</span>

    <span class="c1"># convert coordinates to shapely MultiPoint datastructure</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">sgeometry</span><span class="o">.</span><span class="n">MultiPoint</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

    <span class="n">hull</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">convex_hull</span>
    <span class="n">shapely_to_curve</span><span class="p">(</span><span class="s2">&quot;ConvexHull&quot;</span><span class="p">,</span> <span class="n">hull</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;FINISHED&quot;</span><span class="p">}</span></div>



<span class="c1"># separate function in blender, so you can offset any curve.</span>
<span class="c1"># FIXME: same algorithms as the cutout strategy, because that is hierarchy-respecting.</span>
<div class="viewcode-block" id="silhouette_offset">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.silhouette_offset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">silhouette_offset</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mitrelimit</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Offset the silhouette of a curve or font object in Blender.</span>

<span class="sd">    This function takes an active curve or font object in Blender and</span>
<span class="sd">    creates an offset silhouette based on the specified parameters. It first</span>
<span class="sd">    retrieves the silhouette of the object and then applies a buffer</span>
<span class="sd">    operation to create the offset shape. The resulting shape is then</span>
<span class="sd">    converted back into a curve object in the Blender scene.</span>

<span class="sd">    Args:</span>
<span class="sd">        context (bpy.context): The current Blender context.</span>
<span class="sd">        offset (float): The distance to offset the silhouette.</span>
<span class="sd">        style (int?): The join style for the offset. Defaults to 1.</span>
<span class="sd">        mitrelimit (float?): The mitre limit for the offset. Defaults to 1.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary indicating the operation is finished.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span>
    <span class="k">if</span> <span class="n">ob</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;CURVE&quot;</span> <span class="ow">or</span> <span class="n">ob</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;FONT&quot;</span><span class="p">:</span>
        <span class="n">silhs</span> <span class="o">=</span> <span class="n">curve_to_shapely</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">silhs</span> <span class="o">=</span> <span class="n">get_object_silhouette</span><span class="p">(</span><span class="s2">&quot;OBJECTS&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">ob</span><span class="p">])</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="n">silhs</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">cap_style</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">join_style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">mitre_limit</span><span class="o">=</span><span class="n">mitrelimit</span><span class="p">)</span>
    <span class="n">shapely_to_curve</span><span class="p">(</span><span class="n">ob</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s2">&quot;_offset_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span> <span class="n">mp</span><span class="p">,</span> <span class="n">ob</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">curve_remove_doubles</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;FINISHED&quot;</span><span class="p">}</span></div>



<div class="viewcode-block" id="get_object_silhouette">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.get_object_silhouette">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_object_silhouette</span><span class="p">(</span><span class="n">stype</span><span class="p">,</span> <span class="n">objects</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_modifiers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the silhouette of objects based on the specified type.</span>

<span class="sd">    This function computes the silhouette of a given set of objects in</span>
<span class="sd">    Blender based on the specified type. It can handle both curves and mesh</span>
<span class="sd">    objects, converting curves to polygon format and calculating the</span>
<span class="sd">    silhouette for mesh objects. The function also considers the use of</span>
<span class="sd">    modifiers if specified. The silhouette is generated by processing the</span>
<span class="sd">    geometry of the objects and returning a Shapely representation of the</span>
<span class="sd">    silhouette.</span>

<span class="sd">    Args:</span>
<span class="sd">        stype (str): The type of silhouette to generate (&#39;CURVES&#39; or &#39;OBJECTS&#39;).</span>
<span class="sd">        objects (list?): A list of Blender objects to process. Defaults to None.</span>
<span class="sd">        use_modifiers (bool?): Whether to apply modifiers to the objects. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        shapely.geometry.MultiPolygon: The computed silhouette as a Shapely MultiPolygon.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Silhouette Type:&quot;</span><span class="p">,</span> <span class="n">stype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stype</span> <span class="o">==</span> <span class="s2">&quot;CURVES&quot;</span><span class="p">:</span>  <span class="c1"># curve conversion to polygon format</span>
        <span class="n">allchunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="n">curve_to_chunks</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>
            <span class="n">allchunks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
        <span class="n">silhouette</span> <span class="o">=</span> <span class="n">chunks_to_shapely</span><span class="p">(</span><span class="n">allchunks</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">stype</span> <span class="o">==</span> <span class="s2">&quot;OBJECTS&quot;</span><span class="p">:</span>
        <span class="n">totfaces</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
            <span class="n">totfaces</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ob</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">totfaces</span> <span class="o">&lt;</span> <span class="mi">20000000</span>
        <span class="p">):</span>  <span class="c1"># boolean polygons method originaly was 20 000 poly limit, now limitless,</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Shapely Getting Silhouette&quot;</span><span class="p">)</span>
            <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Object:&quot;</span><span class="p">,</span> <span class="n">ob</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">use_modifiers</span><span class="p">:</span>
                    <span class="n">ob</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">evaluated_get</span><span class="p">(</span><span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">evaluated_depsgraph_get</span><span class="p">())</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">to_mesh</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">data</span>
                <span class="n">mw</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">matrix_world</span>
                <span class="n">mwi</span> <span class="o">=</span> <span class="n">mw</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">rotation_euler</span>
                <span class="n">m</span><span class="o">.</span><span class="n">calc_loop_triangles</span><span class="p">()</span>
                <span class="nb">id</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">e</span> <span class="o">=</span> <span class="mf">0.000001</span>
                <span class="n">scaleup</span> <span class="o">=</span> <span class="mi">100</span>
                <span class="k">for</span> <span class="n">tri</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">loop_triangles</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">n</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">tri</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">z</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># n.z&gt;0.0 and f.area&gt;0.0 :</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">mw</span> <span class="o">@</span> <span class="n">tri</span><span class="o">.</span><span class="n">center</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">xy</span>
                        <span class="k">for</span> <span class="n">vert_index</span> <span class="ow">in</span> <span class="n">tri</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">mw</span> <span class="o">@</span> <span class="n">m</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vert_index</span><span class="p">]</span><span class="o">.</span><span class="n">co</span>
                            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="c1"># print(s)</span>
                            <span class="n">p</span> <span class="o">=</span> <span class="n">spolygon</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                            <span class="c1"># print(dir(p))</span>
                            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_valid</span><span class="p">:</span>
                                <span class="c1"># polys.append(p)</span>
                                <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                        <span class="nb">id</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ob</span><span class="o">.</span><span class="n">select_set</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">totfaces</span> <span class="o">&lt;</span> <span class="mi">20000</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">sops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing in Parts&quot;</span><span class="p">)</span>
                <span class="n">bigshapes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">part</span> <span class="o">=</span> <span class="mi">20000</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">*</span> <span class="n">part</span> <span class="o">&lt;</span> <span class="n">totfaces</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">ar</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">part</span> <span class="p">:</span> <span class="n">i</span> <span class="o">*</span> <span class="n">part</span><span class="p">]</span>
                    <span class="n">bigshapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">ar</span><span class="p">))</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">part</span> <span class="o">&lt;</span> <span class="n">totfaces</span><span class="p">:</span>
                    <span class="n">last_ar</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">part</span> <span class="p">:]</span>
                    <span class="n">bigshapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">last_ar</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Joining&quot;</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">sops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">bigshapes</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Time:&quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span>

            <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">silhouette</span> <span class="o">=</span> <span class="n">shapely_to_multipolygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>  <span class="c1"># [polygon_utils_cam.Shapely2Polygon(p)]</span>

    <span class="k">return</span> <span class="n">silhouette</span></div>



<div class="viewcode-block" id="get_operation_silhouette">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.get_operation_silhouette">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_operation_silhouette</span><span class="p">(</span><span class="n">operation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Gets the silhouette for the given operation.</span>

<span class="sd">    This function determines the silhouette of an operation using image</span>
<span class="sd">    thresholding techniques. It handles different geometry sources, such as</span>
<span class="sd">    objects or images, and applies specific methods based on the type of</span>
<span class="sd">    geometry. If the geometry source is &#39;OBJECT&#39; or &#39;COLLECTION&#39;, it checks</span>
<span class="sd">    whether to process curves or not. The function also considers the number</span>
<span class="sd">    of faces in mesh objects to decide on the appropriate method for</span>
<span class="sd">    silhouette extraction.</span>

<span class="sd">    Args:</span>
<span class="sd">        operation (Operation): An object containing the necessary data</span>

<span class="sd">    Returns:</span>
<span class="sd">        Silhouette: The computed silhouette for the operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">operation</span><span class="o">.</span><span class="n">update_silhouette_tag</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">objects</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">operation</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s2">&quot;OBJECT&quot;</span> <span class="ow">or</span> <span class="n">operation</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s2">&quot;COLLECTION&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">operation</span><span class="o">.</span><span class="n">onlycurves</span><span class="p">:</span>
                <span class="n">stype</span> <span class="o">=</span> <span class="s2">&quot;OBJECTS&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stype</span> <span class="o">=</span> <span class="s2">&quot;CURVES&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stype</span> <span class="o">=</span> <span class="s2">&quot;IMAGE&quot;</span>

        <span class="n">totfaces</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">stype</span> <span class="o">==</span> <span class="s2">&quot;OBJECTS&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">operation</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ob</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;MESH&quot;</span><span class="p">:</span>
                    <span class="n">totfaces</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ob</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">stype</span> <span class="o">==</span> <span class="s2">&quot;OBJECTS&quot;</span> <span class="ow">and</span> <span class="n">totfaces</span> <span class="o">&gt;</span> <span class="mi">200000</span><span class="p">)</span> <span class="ow">or</span> <span class="n">stype</span> <span class="o">==</span> <span class="s2">&quot;IMAGE&quot;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Image Method&quot;</span><span class="p">)</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">render_sample_image</span><span class="p">(</span><span class="n">operation</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stype</span> <span class="o">==</span> <span class="s2">&quot;OBJECTS&quot;</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">&gt;</span> <span class="n">operation</span><span class="o">.</span><span class="n">min_z</span> <span class="o">-</span> <span class="mf">0.0000001</span>
                <span class="c1"># np.min(operation.zbuffer_image)-0.0000001#</span>
                <span class="c1"># #the small number solves issue with totally flat meshes, which people tend to mill instead of</span>
                <span class="c1"># proper pockets. then the minimum was also maximum, and it didn&#39;t detect contour.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># this fixes another numeric imprecision.</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">zbuffer_image</span><span class="p">)</span>

            <span class="n">chunks</span> <span class="o">=</span> <span class="n">image_to_chunks</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">operation</span><span class="o">.</span><span class="n">silhouette</span> <span class="o">=</span> <span class="n">chunks_to_shapely</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
        <span class="c1"># print(operation.silhouette)</span>
        <span class="c1"># this conversion happens because we need the silh to be oriented, for milling directions.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Object Method for Retrieving Silhouette&quot;</span><span class="p">)</span>
            <span class="n">operation</span><span class="o">.</span><span class="n">silhouette</span> <span class="o">=</span> <span class="n">get_object_silhouette</span><span class="p">(</span>
                <span class="n">stype</span><span class="p">,</span> <span class="n">objects</span><span class="o">=</span><span class="n">operation</span><span class="o">.</span><span class="n">objects</span><span class="p">,</span> <span class="n">use_modifiers</span><span class="o">=</span><span class="n">operation</span><span class="o">.</span><span class="n">use_modifiers</span>
            <span class="p">)</span>

        <span class="n">operation</span><span class="o">.</span><span class="n">update_silhouette_tag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">silhouette</span></div>



<div class="viewcode-block" id="get_object_outline">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.get_object_outline">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_object_outline</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">Offset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the outline of a geometric object based on specified parameters.</span>

<span class="sd">    This function generates an outline for a given geometric object by</span>
<span class="sd">    applying a buffer operation to its polygons. The buffer radius can be</span>
<span class="sd">    adjusted based on the `radius` parameter, and the operation can be</span>
<span class="sd">    offset based on the `Offset` flag. The function also considers whether</span>
<span class="sd">    the polygons should be merged or not, depending on the properties of the</span>
<span class="sd">    object `o`.</span>

<span class="sd">    Args:</span>
<span class="sd">        radius (float): The radius for the buffer operation.</span>
<span class="sd">        o (object): An object containing properties that influence the outline generation.</span>
<span class="sd">        Offset (bool): A flag indicating whether to apply a positive or negative offset.</span>

<span class="sd">    Returns:</span>
<span class="sd">        MultiPolygon: The resulting outline of the geometric object as a MultiPolygon.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># FIXME: make this one operation independent</span>
    <span class="c1"># circle detail, optimize, optimize thresold.</span>

    <span class="n">polygons</span> <span class="o">=</span> <span class="n">get_operation_silhouette</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># print(&#39;offseting polygons&#39;)</span>

    <span class="k">if</span> <span class="n">Offset</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">outlines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">straight</span><span class="p">:</span>
        <span class="n">join</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">join</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polygons</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">polygon_list</span> <span class="o">=</span> <span class="n">polygons</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">polygon_list</span> <span class="o">=</span> <span class="n">polygons</span><span class="o">.</span><span class="n">geoms</span>

    <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">polygon_list</span><span class="p">:</span>  <span class="c1"># sort by size before this???</span>
        <span class="c1"># print(p1.type, len(polygons))</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">radius</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span>
                <span class="n">radius</span> <span class="o">*</span> <span class="n">offset</span><span class="p">,</span>
                <span class="n">resolution</span><span class="o">=</span><span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">circle_detail</span><span class="p">,</span>
                <span class="n">join_style</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
                <span class="n">mitre_limit</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">outlines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>

    <span class="c1"># print(outlines)</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">dont_merge</span><span class="p">:</span>
        <span class="n">outline</span> <span class="o">=</span> <span class="n">sgeometry</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">(</span><span class="n">outlines</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">outline</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">outlines</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">outline</span></div>



<div class="viewcode-block" id="get_ambient">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.get_ambient">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_ambient</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate and update the ambient geometry based on the provided object.</span>

<span class="sd">    This function computes the ambient shape for a given object based on its</span>
<span class="sd">    properties, such as cutter restrictions and ambient behavior. It</span>
<span class="sd">    determines the appropriate radius and creates the ambient geometry</span>
<span class="sd">    either from the silhouette or as a polygon defined by the object&#39;s</span>
<span class="sd">    minimum and maximum coordinates. If a limit curve is specified, it will</span>
<span class="sd">    also intersect the ambient shape with the limit polygon.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): An object containing properties that define the ambient behavior,</span>
<span class="sd">            cutter restrictions, and limit curve.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: The function updates the ambient property of the object in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">update_ambient_tag</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">ambient_cutter_restrict</span><span class="p">:</span>  <span class="c1"># cutter stays in ambient &amp; limit curve</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">cutter_diameter</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">ambient_behaviour</span> <span class="o">==</span> <span class="s2">&quot;AROUND&quot;</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ambient_radius</span> <span class="o">-</span> <span class="n">m</span>
            <span class="c1"># in this method we need ambient from silhouette</span>
            <span class="n">o</span><span class="o">.</span><span class="n">ambient</span> <span class="o">=</span> <span class="n">get_object_outline</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">o</span><span class="o">.</span><span class="n">ambient</span> <span class="o">=</span> <span class="n">spolygon</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">m</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">m</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">m</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">m</span><span class="p">),</span>
                    <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">m</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">m</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">use_limit_curve</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">limit_curve</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="n">limit_curve</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">limit_curve</span><span class="p">]</span>
                <span class="n">polys</span> <span class="o">=</span> <span class="n">curve_to_shapely</span><span class="p">(</span><span class="n">limit_curve</span><span class="p">)</span>
                <span class="n">o</span><span class="o">.</span><span class="n">limit_poly</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">ambient_cutter_restrict</span><span class="p">:</span>
                    <span class="n">o</span><span class="o">.</span><span class="n">limit_poly</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">limit_poly</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span>
                        <span class="n">o</span><span class="o">.</span><span class="n">cutter_diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">circle_detail</span>
                    <span class="p">)</span>
            <span class="n">o</span><span class="o">.</span><span class="n">ambient</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ambient</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">limit_poly</span><span class="p">)</span>
    <span class="n">o</span><span class="o">.</span><span class="n">update_ambient_tag</span> <span class="o">=</span> <span class="kc">False</span></div>



<span class="c1"># samples in both modes now - image and bullet collision too.</span>
<div class="viewcode-block" id="sample_chunks">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.sample_chunks">[docs]</a>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">sample_chunks</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">pathSamples</span><span class="p">,</span> <span class="n">layers</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample chunks of paths based on the provided parameters.</span>

<span class="sd">    This function processes the given path samples and layers to generate</span>
<span class="sd">    chunks of points that represent the sampled paths. It takes into account</span>
<span class="sd">    various optimization settings and strategies to determine how the points</span>
<span class="sd">    are sampled and organized into layers. The function handles different</span>
<span class="sd">    scenarios based on the object&#39;s properties and the specified layers,</span>
<span class="sd">    ensuring that the resulting chunks are correctly structured for further</span>
<span class="sd">    processing.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): An object containing various properties and settings</span>
<span class="sd">            related to the sampling process.</span>
<span class="sd">        pathSamples (list): A list of path samples to be processed.</span>
<span class="sd">        layers (list): A list of layers defining the z-coordinate ranges</span>
<span class="sd">            for sampling.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of sampled chunks, each containing points that represent</span>
<span class="sd">            the sampled paths.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">minz</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">maxz</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span>
    <span class="n">get_ambient</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span><span class="p">:</span>  <span class="c1"># prepare collision world</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">oclSample</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">pathSamples</span><span class="p">)</span>
            <span class="n">cutterdepth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">update_bullet_collision_tag</span><span class="p">:</span>
                <span class="n">prepare_bullet_collision</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

                <span class="n">o</span><span class="o">.</span><span class="n">update_bullet_collision_tag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># print (o.ambient)</span>
            <span class="n">cutter</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">cutter_shape</span>
            <span class="n">cutterdepth</span> <span class="o">=</span> <span class="n">cutter</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">z</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># or prepare offset image, but not in some strategies.</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s2">&quot;WATERLINE&quot;</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">prepare_area</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="n">pixsize</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span>

        <span class="n">coordoffset</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span> <span class="o">+</span> <span class="n">pixsize</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># -m</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">cutter_diameter</span> <span class="o">/</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">res</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># print(&#39;sampling paths&#39;)</span>

    <span class="n">totlen</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># total length of all chunks, to estimate sampling time.</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">pathSamples</span><span class="p">:</span>
        <span class="n">totlen</span> <span class="o">+=</span> <span class="n">ch</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
    <span class="n">layerchunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">minz</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">min_z</span> <span class="o">-</span> <span class="mf">0.000001</span>  <span class="c1"># correction for image method problems</span>
    <span class="n">layeractivechunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lastrunchunks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
        <span class="n">layerchunks</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="n">layeractivechunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CamPathChunkBuilder</span><span class="p">([]))</span>
        <span class="n">lastrunchunks</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

    <span class="n">zinvert</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">inverse</span><span class="p">:</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">object_name</span><span class="p">]</span>
        <span class="n">zinvert</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">maxz</span>  <span class="c1"># ob.bound_box[6][2]</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total Sample Points </span><span class="si">{</span><span class="n">totlen</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">last_percent</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1"># timing for optimisation</span>
    <span class="n">samplingtime</span> <span class="o">=</span> <span class="n">timing_init</span><span class="p">()</span>
    <span class="n">sortingtime</span> <span class="o">=</span> <span class="n">timing_init</span><span class="p">()</span>
    <span class="n">totaltime</span> <span class="o">=</span> <span class="n">timing_init</span><span class="p">()</span>
    <span class="n">timing_start</span><span class="p">(</span><span class="n">totaltime</span><span class="p">)</span>
    <span class="n">lastz</span> <span class="o">=</span> <span class="n">minz</span>
    <span class="k">for</span> <span class="n">patternchunk</span> <span class="ow">in</span> <span class="n">pathSamples</span><span class="p">:</span>
        <span class="n">thisrunchunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">thisrunchunks</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="n">lastlayer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">currentlayer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">lastsample</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># threads_count=4</span>

        <span class="c1"># for t in range(0,threads):</span>
        <span class="n">our_points</span> <span class="o">=</span> <span class="n">patternchunk</span><span class="o">.</span><span class="n">get_points_np</span><span class="p">()</span>
        <span class="n">ambient_contains</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ambient</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">our_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">in_ambient</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">our_points</span><span class="p">,</span> <span class="n">ambient_contains</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s2">&quot;WATERLINE&quot;</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">totlen</span><span class="p">)</span> <span class="o">!=</span> <span class="n">last_percent</span><span class="p">:</span>
                <span class="n">last_percent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">totlen</span><span class="p">)</span>
                <span class="k">await</span> <span class="n">progress_async</span><span class="p">(</span><span class="s2">&quot;Sampling Paths&quot;</span><span class="p">,</span> <span class="n">last_percent</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">in_ambient</span><span class="p">:</span>
                <span class="n">newsample</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">minz</span> <span class="o">&gt;</span> <span class="n">z</span><span class="p">:</span>
                        <span class="n">z</span> <span class="o">=</span> <span class="n">minz</span>
                    <span class="n">newsample</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
                <span class="c1"># ampling</span>
                <span class="k">elif</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">lastsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># this is an optimalization,</span>
                        <span class="c1"># search only for near depths to the last sample. Saves about 30% of sampling time.</span>
                        <span class="n">z</span> <span class="o">=</span> <span class="n">get_sample_bullet</span><span class="p">(</span>
                            <span class="n">cutter</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cutterdepth</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">lastsample</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">distance_along_paths</span>
                        <span class="p">)</span>  <span class="c1"># first try to the last sample</span>
                        <span class="k">if</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">minz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">z</span> <span class="o">=</span> <span class="n">get_sample_bullet</span><span class="p">(</span>
                                <span class="n">cutter</span><span class="p">,</span>
                                <span class="n">x</span><span class="p">,</span>
                                <span class="n">y</span><span class="p">,</span>
                                <span class="n">cutterdepth</span><span class="p">,</span>
                                <span class="n">lastsample</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">distance_along_paths</span><span class="p">,</span>
                                <span class="n">minz</span><span class="p">,</span>
                            <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">z</span> <span class="o">=</span> <span class="n">get_sample_bullet</span><span class="p">(</span><span class="n">cutter</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cutterdepth</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">minz</span><span class="p">)</span>

                <span class="c1"># print(z)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">timing_start</span><span class="p">(</span><span class="n">samplingtime</span><span class="p">)</span>
                    <span class="n">xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">minx</span><span class="p">)</span> <span class="o">/</span> <span class="n">pixsize</span> <span class="o">+</span> <span class="n">coordoffset</span>
                    <span class="n">ys</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">miny</span><span class="p">)</span> <span class="o">/</span> <span class="n">pixsize</span> <span class="o">+</span> <span class="n">coordoffset</span>
                    <span class="n">timing_add</span><span class="p">(</span><span class="n">samplingtime</span><span class="p">)</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">get_sample_image</span><span class="p">((</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">),</span> <span class="n">o</span><span class="o">.</span><span class="n">offset_image</span><span class="p">,</span> <span class="n">minz</span><span class="p">)</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">skin</span>

                <span class="c1">################################</span>
                <span class="c1"># handling samples</span>
                <span class="c1">############################################</span>

                <span class="k">if</span> <span class="n">minz</span> <span class="o">&gt;</span> <span class="n">z</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">minz</span>
                <span class="n">newsample</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
                <span class="n">terminatechunk</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">ch</span> <span class="o">=</span> <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">newsample</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">lastlayer</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># rather the last sample here ? has to be set to None,</span>
                    <span class="c1"># since sometimes lastsample vs lastlayer didn&#39;t fit and did ugly ugly stuff....</span>
                    <span class="k">if</span> <span class="n">lastsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i2</span><span class="p">,</span> <span class="n">l2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">l2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lastsample</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="n">lastlayer</span> <span class="o">=</span> <span class="n">i2</span>

                    <span class="n">currentlayer</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="c1"># and lastsample[2]!=newsample[2]:</span>
                    <span class="k">if</span> <span class="n">lastlayer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lastlayer</span> <span class="o">!=</span> <span class="n">currentlayer</span><span class="p">:</span>
                        <span class="c1"># #sampling for sorted paths in layers- to go to the border of the sampled layer at least...</span>
                        <span class="c1"># there was a bug here, but should be fixed.</span>
                        <span class="k">if</span> <span class="n">currentlayer</span> <span class="o">&lt;</span> <span class="n">lastlayer</span><span class="p">:</span>
                            <span class="n">growing</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">currentlayer</span><span class="p">,</span> <span class="n">lastlayer</span><span class="p">)</span>
                            <span class="n">spliti</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">lastlayer</span><span class="p">,</span> <span class="n">currentlayer</span><span class="p">)</span>
                            <span class="n">growing</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="n">spliti</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="c1"># print(r)</span>
                        <span class="n">li</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">ls</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                            <span class="n">splitz</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="n">ls</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                            <span class="c1"># print(ls)</span>

                            <span class="n">v1</span> <span class="o">=</span> <span class="n">lastsample</span>
                            <span class="n">v2</span> <span class="o">=</span> <span class="n">newsample</span>
                            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">protect_vertical</span><span class="p">:</span>
                                <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">is_vertical_limit</span><span class="p">(</span>
                                    <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">protect_vertical_limit</span>
                                <span class="p">)</span>
                            <span class="n">v1</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
                            <span class="n">v2</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
                            <span class="c1"># print(v1,v2)</span>

                            <span class="c1"># Prevent divide by zero:</span>
                            <span class="n">dz</span> <span class="o">=</span> <span class="n">v2</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">v1</span><span class="o">.</span><span class="n">z</span>
                            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dz</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span>
                                <span class="c1"># no vertical change – nothing to split</span>
                                <span class="k">continue</span>
                            <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">splitz</span> <span class="o">-</span> <span class="n">v1</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="n">dz</span>
                            <span class="c1"># print(ratio)</span>
                            <span class="n">betweensample</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="n">v2</span> <span class="o">-</span> <span class="n">v1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ratio</span>

                            <span class="c1"># ch.points.append(betweensample.to_tuple())</span>

                            <span class="k">if</span> <span class="n">growing</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">li</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                                        <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweensample</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">()</span>
                                    <span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweensample</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())</span>
                                <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweensample</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># print(v1,v2,betweensample,lastlayer,currentlayer)</span>
                                <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweensample</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())</span>
                                <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">betweensample</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())</span>

                            <span class="n">li</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># this chunk is terminated, and allready in layerchunks /</span>

                    <span class="c1"># ch.points.append(betweensample.to_tuple())#</span>
                    <span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newsample</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">newsample</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">newsample</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">newsample</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">newsample</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>  <span class="c1"># terminate chunk</span>
                    <span class="n">terminatechunk</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">terminatechunk</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">as_chunk</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">to_chunk</span><span class="p">()</span>
                        <span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">as_chunk</span><span class="p">)</span>
                        <span class="n">thisrunchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">as_chunk</span><span class="p">)</span>
                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">([])</span>
            <span class="n">lastsample</span> <span class="o">=</span> <span class="n">newsample</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">as_chunk</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">to_chunk</span><span class="p">()</span>
                <span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">as_chunk</span><span class="p">)</span>
                <span class="n">thisrunchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">as_chunk</span><span class="p">)</span>
                <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">([])</span>

            <span class="c1"># PARENTING</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;PARALLEL&quot;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;CROSS&quot;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;OUTLINEFILL&quot;</span><span class="p">:</span>
                <span class="n">timing_start</span><span class="p">(</span><span class="n">sortingtime</span><span class="p">)</span>
                <span class="n">parent_child_distance</span><span class="p">(</span><span class="n">thisrunchunks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lastrunchunks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">o</span><span class="p">)</span>
                <span class="n">timing_add</span><span class="p">(</span><span class="n">sortingtime</span><span class="p">)</span>

        <span class="n">lastrunchunks</span> <span class="o">=</span> <span class="n">thisrunchunks</span>

    <span class="c1"># print(len(layerchunks[i]))</span>
    <span class="n">progress</span><span class="p">(</span><span class="s2">&quot;Checking Relations Between Paths&quot;</span><span class="p">)</span>
    <span class="n">timing_start</span><span class="p">(</span><span class="n">sortingtime</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;PARALLEL&quot;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;CROSS&quot;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;OUTLINEFILL&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># sorting help so that upper layers go first always</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">parents</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># only pick chunks that should have connectivity assigned - &#39;last&#39; and &#39;first&#39; ones of the layer.</span>
                <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ch</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                        <span class="n">parents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ch1</span> <span class="ow">in</span> <span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ch1</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                        <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch1</span><span class="p">)</span>

                <span class="c1"># parent only last and first chunk, before it did this for all.</span>
                <span class="n">parent_child</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
    <span class="n">timing_add</span><span class="p">(</span><span class="n">sortingtime</span><span class="p">)</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">ramp</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">zstart</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">zend</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">timing_add</span><span class="p">(</span><span class="n">totaltime</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">samplingtime</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sortingtime</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">totaltime</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chunks</span></div>



<div class="viewcode-block" id="connect_chunks_low">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.connect_chunks_low">[docs]</a>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">connect_chunks_low</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Connects chunks that are close to each other without lifting, sampling</span>
<span class="sd">    them &#39;low&#39;.</span>

<span class="sd">    This function processes a list of chunks and connects those that are</span>
<span class="sd">    within a specified distance based on the provided options. It takes into</span>
<span class="sd">    account various strategies for connecting the chunks, including &#39;CARVE&#39;,</span>
<span class="sd">    &#39;PENCIL&#39;, and &#39;MEDIAL_AXIS&#39;, and adjusts the merging distance</span>
<span class="sd">    accordingly. The function also handles specific movement settings, such</span>
<span class="sd">    as whether to stay low or to merge distances, and may resample chunks if</span>
<span class="sd">    certain optimization conditions are met.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunks (list): A list of chunk objects to be connected.</span>
<span class="sd">        o (object): An options object containing movement and strategy parameters.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of connected chunk objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">stay_low</span> <span class="ow">or</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;CARVE&quot;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">carve_depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">chunks</span>

    <span class="n">connectedchunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">chunks_to_resample</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># for OpenCAMLib sampling</span>
    <span class="n">mergedist</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">distance_between_paths</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;PENCIL&quot;</span>
    <span class="p">):</span>  <span class="c1"># this is bigger for pencil path since it goes on the surface to clean up the rests,</span>
        <span class="c1"># and can go to close points on the surface without fear of going deep into material.</span>
        <span class="n">mergedist</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">distance_between_paths</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;MEDIAL_AXIS&quot;</span><span class="p">:</span>
        <span class="n">mergedist</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">medial_axis_subdivision</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">parallel_step_back</span><span class="p">:</span>
        <span class="n">mergedist</span> <span class="o">*=</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">merge_distance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">mergedist</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">merge_distance</span>
    <span class="c1"># mergedist=10</span>
    <span class="n">lastch</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lastch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">distance_start</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mergedist</span><span class="p">):</span>
                <span class="c1"># CARVE should lift allways, when it goes below surface...</span>
                <span class="c1"># print(mergedist,ch.distance(pos,o))</span>
                <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;PARALLEL&quot;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;CROSS&quot;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;PENCIL&quot;</span><span class="p">:</span>
                    <span class="c1"># for these paths sorting happens after sampling, thats why they need resample the connection</span>
                    <span class="n">between</span> <span class="o">=</span> <span class="n">sample_path_low</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">lastch</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># print(&#39;addbetwee&#39;)</span>
                    <span class="n">between</span> <span class="o">=</span> <span class="n">sample_path_low</span><span class="p">(</span>
                        <span class="n">o</span><span class="p">,</span> <span class="n">lastch</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="kc">False</span>
                    <span class="p">)</span>  <span class="c1"># other paths either dont use sampling or are sorted before it.</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span>
                    <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span>
                    <span class="ow">and</span> <span class="p">(</span>
                        <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;PARALLEL&quot;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;CROSS&quot;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;PENCIL&quot;</span>
                    <span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">chunks_to_resample</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">connectedchunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">connectedchunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">between</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
                    <span class="p">)</span>

                <span class="n">connectedchunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">between</span><span class="o">.</span><span class="n">get_points_np</span><span class="p">())</span>
                <span class="n">connectedchunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">get_points_np</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">connectedchunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
            <span class="n">lastch</span> <span class="o">=</span> <span class="n">ch</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">lastch</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span>
        <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span>
        <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s2">&quot;CUTOUT&quot;</span>
        <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s2">&quot;POCKET&quot;</span>
        <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s2">&quot;WATERLINE&quot;</span>
    <span class="p">):</span>
        <span class="k">await</span> <span class="n">oclResampleChunks</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">chunks_to_resample</span><span class="p">,</span> <span class="n">use_cached_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">connectedchunks</span></div>



<div class="viewcode-block" id="sort_chunks">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.sort_chunks">[docs]</a>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">sort_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">last_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sort a list of chunks based on a specified strategy.</span>

<span class="sd">    This function sorts a list of chunks according to the provided options</span>
<span class="sd">    and the current position. It utilizes a recursive approach to find the</span>
<span class="sd">    closest chunk to the current position and adapts its distance if it has</span>
<span class="sd">    not been sorted before. The function also handles progress updates</span>
<span class="sd">    asynchronously and adjusts the recursion limit to accommodate deep</span>
<span class="sd">    recursion scenarios.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunks (list): A list of chunk objects to be sorted.</span>
<span class="sd">        o (object): An options object that contains sorting strategy and other parameters.</span>
<span class="sd">        last_pos (tuple?): The last known position as a tuple of coordinates.</span>
<span class="sd">            Defaults to None, which initializes the position to (0, 0, 0).</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A sorted list of chunk objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s2">&quot;WATERLINE&quot;</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">progress_async</span><span class="p">(</span><span class="s2">&quot;Sorting Paths&quot;</span><span class="p">)</span>
    <span class="c1"># the getNext() function of CamPathChunk was running out of recursion limits.</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>
    <span class="n">sortedchunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">chunks_to_resample</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">lastch</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">last_progress_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">last_pos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">last_pos</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s2">&quot;WATERLINE&quot;</span> <span class="ow">and</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">last_progress_time</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">progress_async</span><span class="p">(</span><span class="s2">&quot;Sorting Paths&quot;</span><span class="p">,</span> <span class="mf">100.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">total</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span> <span class="o">/</span> <span class="n">total</span><span class="p">)</span>
            <span class="n">last_progress_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">sortedchunks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">lastch</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">):</span>  <span class="c1"># first chunk or when there are no parents -&gt; parents come after children here...</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">get_closest_chunk</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">lastch</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># looks in parents for next candidate, recursively</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">lastch</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">get_next_closest</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="n">get_closest_chunk</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># found next chunk, append it to list</span>
            <span class="c1"># only adaptdist the chunk if it has not been sorted before</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ch</span><span class="o">.</span><span class="n">sorted</span><span class="p">:</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">adapt_distance</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">sorted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># print(len(ch.parents),&#39;children&#39;)</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
            <span class="n">sortedchunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
            <span class="n">lastch</span> <span class="o">=</span> <span class="n">ch</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">lastch</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># print(i, len(chunks))</span>
        <span class="c1"># experimental fix for infinite loop problem</span>
        <span class="c1"># else:</span>
        <span class="c1"># THIS PROBLEM WASN&#39;T HERE AT ALL. but keeping it here, it might fix the problems somwhere else:)</span>
        <span class="c1"># can&#39;t find chunks close enough and still some chunks left</span>
        <span class="c1"># to be sorted. For now just move the remaining chunks over to</span>
        <span class="c1"># the sorted list.</span>
        <span class="c1"># This fixes an infinite loop condition that occurs sometimes.</span>
        <span class="c1"># This is a bandaid fix: need to find the root cause of this problem</span>
        <span class="c1"># suspect it has to do with the sorted flag?</span>
        <span class="c1"># print(&quot;no chunks found closest. Chunks not sorted: &quot;, len(chunks))</span>
        <span class="c1"># sortedchunks.extend(chunks)</span>
        <span class="c1"># chunks[:] = []</span>

        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;POCKET&quot;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">pocket_option</span> <span class="o">==</span> <span class="s2">&quot;OUTSIDE&quot;</span><span class="p">:</span>
        <span class="n">sortedchunks</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s2">&quot;DRILL&quot;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s2">&quot;OUTLINEFILL&quot;</span><span class="p">:</span>
        <span class="c1"># THIS SHOULD AVOID ACTUALLY MOST STRATEGIES, THIS SHOULD BE DONE MANUALLY,</span>
        <span class="c1"># BECAUSE SOME STRATEGIES GET SORTED TWICE.</span>
        <span class="n">sortedchunks</span> <span class="o">=</span> <span class="k">await</span> <span class="n">connect_chunks_low</span><span class="p">(</span><span class="n">sortedchunks</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sortedchunks</span></div>



<div class="viewcode-block" id="oclResampleChunks">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.oclResampleChunks">[docs]</a>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">oclResampleChunks</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="n">chunks_to_resample</span><span class="p">,</span> <span class="n">use_cached_mesh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Resample chunks of data using OpenCL operations.</span>

<span class="sd">    This function takes a list of chunks to resample and performs an OpenCL</span>
<span class="sd">    sampling operation on them. It first prepares a temporary chunk that</span>
<span class="sd">    collects points from the specified chunks. Then, it calls the</span>
<span class="sd">    `ocl_sample` function to perform the sampling operation. After obtaining</span>
<span class="sd">    the samples, it updates the z-coordinates of the points in each chunk</span>
<span class="sd">    based on the sampled values.</span>

<span class="sd">    Args:</span>
<span class="sd">        operation (OperationType): The OpenCL operation to be performed.</span>
<span class="sd">        chunks_to_resample (list): A list of tuples, where each tuple contains</span>
<span class="sd">            a chunk object and its corresponding start index and length for</span>
<span class="sd">            resampling.</span>
<span class="sd">        use_cached_mesh (bool): A flag indicating whether to use cached mesh</span>
<span class="sd">            data during the sampling process.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: This function does not return a value but modifies the input</span>
<span class="sd">            chunks in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tmp_chunks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">tmp_chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">CamPathChunk</span><span class="p">(</span><span class="n">inpoints</span><span class="o">=</span><span class="p">[]))</span>
    <span class="k">for</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">i_start</span><span class="p">,</span> <span class="n">i_length</span> <span class="ow">in</span> <span class="n">chunks_to_resample</span><span class="p">:</span>
        <span class="n">tmp_chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chunk</span><span class="o">.</span><span class="n">get_points_np</span><span class="p">()[</span><span class="n">i_start</span> <span class="p">:</span> <span class="n">i_start</span> <span class="o">+</span> <span class="n">i_length</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i_start</span><span class="p">,</span> <span class="n">i_length</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_chunks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>

    <span class="n">samples</span> <span class="o">=</span> <span class="k">await</span> <span class="n">ocl_sample</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="n">tmp_chunks</span><span class="p">,</span> <span class="n">use_cached_mesh</span><span class="o">=</span><span class="n">use_cached_mesh</span><span class="p">)</span>

    <span class="n">sample_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">i_start</span><span class="p">,</span> <span class="n">i_length</span> <span class="ow">in</span> <span class="n">chunks_to_resample</span><span class="p">:</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">z</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">samples</span><span class="p">[</span><span class="n">sample_index</span> <span class="p">:</span> <span class="n">sample_index</span> <span class="o">+</span> <span class="n">i_length</span><span class="p">]])</span> <span class="o">/</span> <span class="n">OCL_SCALE</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="n">chunk</span><span class="o">.</span><span class="n">get_points_np</span><span class="p">()</span>
        <span class="n">pt_z</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">i_start</span> <span class="p">:</span> <span class="n">i_start</span> <span class="o">+</span> <span class="n">i_length</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">pt_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">pt_z</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">pt_z</span><span class="p">)</span>

        <span class="n">sample_index</span> <span class="o">+=</span> <span class="n">i_length</span></div>



<div class="viewcode-block" id="oclGetWaterline">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.oclGetWaterline">[docs]</a>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">oclGetWaterline</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="n">chunks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate waterline paths for a given machining operation.</span>

<span class="sd">    This function calculates the waterline paths based on the provided</span>
<span class="sd">    machining operation and its parameters. It determines the appropriate</span>
<span class="sd">    cutter type and dimensions, sets up the waterline object with the</span>
<span class="sd">    corresponding STL file, and processes each layer to generate the</span>
<span class="sd">    machining paths. The resulting paths are stored in the provided chunks</span>
<span class="sd">    list. The function also handles different cutter types, including end</span>
<span class="sd">    mills, ball nose cutters, and V-carve cutters.</span>

<span class="sd">    Args:</span>
<span class="sd">        operation (Operation): An object representing the machining operation,</span>
<span class="sd">            containing details such as cutter type, diameter, and minimum Z height.</span>
<span class="sd">        chunks (list): A list that will be populated with the generated</span>
<span class="sd">            machining path chunks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">layers</span> <span class="o">=</span> <span class="n">oclWaterlineLayerHeights</span><span class="p">(</span><span class="n">operation</span><span class="p">)</span>
    <span class="n">oclSTL</span> <span class="o">=</span> <span class="n">get_oclSTL</span><span class="p">(</span><span class="n">operation</span><span class="p">)</span>

    <span class="n">op_cutter_type</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">cutter_type</span>
    <span class="n">op_cutter_diameter</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">cutter_diameter</span>
    <span class="n">op_minz</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">min_z</span>
    <span class="k">if</span> <span class="n">op_cutter_type</span> <span class="o">==</span> <span class="s2">&quot;VCARVE&quot;</span><span class="p">:</span>
        <span class="n">op_cutter_tip_angle</span> <span class="o">=</span> <span class="n">operation</span><span class="p">[</span><span class="s2">&quot;cutter_tip_angle&quot;</span><span class="p">]</span>

    <span class="n">cutter</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># TODO: automatically determine necessary cutter length depending on object size</span>
    <span class="n">cutter_length</span> <span class="o">=</span> <span class="mi">150</span>

    <span class="k">if</span> <span class="n">op_cutter_type</span> <span class="o">==</span> <span class="s2">&quot;END&quot;</span><span class="p">:</span>
        <span class="n">cutter</span> <span class="o">=</span> <span class="n">ocl</span><span class="o">.</span><span class="n">CylCutter</span><span class="p">((</span><span class="n">op_cutter_diameter</span> <span class="o">+</span> <span class="n">operation</span><span class="o">.</span><span class="n">skin</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">cutter_length</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">op_cutter_type</span> <span class="o">==</span> <span class="s2">&quot;BALLNOSE&quot;</span><span class="p">:</span>
        <span class="n">cutter</span> <span class="o">=</span> <span class="n">ocl</span><span class="o">.</span><span class="n">BallCutter</span><span class="p">((</span><span class="n">op_cutter_diameter</span> <span class="o">+</span> <span class="n">operation</span><span class="o">.</span><span class="n">skin</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">cutter_length</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">op_cutter_type</span> <span class="o">==</span> <span class="s2">&quot;VCARVE&quot;</span><span class="p">:</span>
        <span class="n">cutter</span> <span class="o">=</span> <span class="n">ocl</span><span class="o">.</span><span class="n">ConeCutter</span><span class="p">(</span>
            <span class="p">(</span><span class="n">op_cutter_diameter</span> <span class="o">+</span> <span class="n">operation</span><span class="o">.</span><span class="n">skin</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">op_cutter_tip_angle</span><span class="p">,</span> <span class="n">cutter_length</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cutter Unsupported: </span><span class="si">{0}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op_cutter_type</span><span class="p">))</span>
        <span class="n">quit</span><span class="p">()</span>

    <span class="n">waterline</span> <span class="o">=</span> <span class="n">ocl</span><span class="o">.</span><span class="n">Waterline</span><span class="p">()</span>
    <span class="n">waterline</span><span class="o">.</span><span class="n">setSTL</span><span class="p">(</span><span class="n">oclSTL</span><span class="p">)</span>
    <span class="n">waterline</span><span class="o">.</span><span class="n">setCutter</span><span class="p">(</span><span class="n">cutter</span><span class="p">)</span>
    <span class="n">waterline</span><span class="o">.</span><span class="n">setSampling</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>  <span class="c1"># TODO: add sampling setting to UI</span>
    <span class="n">last_pos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">height</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
        <span class="n">layer_chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">await</span> <span class="n">progress_async</span><span class="p">(</span><span class="s2">&quot;Waterline&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="mi">100</span> <span class="o">*</span> <span class="n">count</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">)))</span>
        <span class="n">waterline</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="n">waterline</span><span class="o">.</span><span class="n">setZ</span><span class="p">(</span><span class="n">height</span> <span class="o">*</span> <span class="n">OCL_SCALE</span><span class="p">)</span>
        <span class="n">waterline</span><span class="o">.</span><span class="n">run2</span><span class="p">()</span>
        <span class="n">wl_loops</span> <span class="o">=</span> <span class="n">waterline</span><span class="o">.</span><span class="n">getLoops</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">wl_loops</span><span class="p">:</span>
            <span class="n">inpoints</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">inpoints</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">OCL_SCALE</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">OCL_SCALE</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">z</span> <span class="o">/</span> <span class="n">OCL_SCALE</span><span class="p">))</span>
            <span class="n">inpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="n">CamPathChunk</span><span class="p">(</span><span class="n">inpoints</span><span class="o">=</span><span class="n">inpoints</span><span class="p">)</span>
            <span class="n">chunk</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">layer_chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="c1"># sort chunks so that ordering is stable</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="k">await</span> <span class="n">sort_chunks</span><span class="p">(</span><span class="n">layer_chunks</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">last_pos</span><span class="o">=</span><span class="n">last_pos</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">last_pos</span> <span class="o">=</span> <span class="n">chunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>



<span class="c1"># search edges for pencil strategy, another try.</span>
<div class="viewcode-block" id="image_edge_search_on_line">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.image_edge_search_on_line">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">image_edge_search_on_line</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">ar</span><span class="p">,</span> <span class="n">zimage</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Search for edges in an image using a pencil strategy.</span>

<span class="sd">    This function implements an edge detection algorithm that simulates a</span>
<span class="sd">    pencil-like movement across the image represented by a 2D array. It</span>
<span class="sd">    identifies white pixels and builds chunks of points based on the</span>
<span class="sd">    detected edges. The algorithm iteratively explores possible directions</span>
<span class="sd">    to find and track the edges until a specified condition is met, such as</span>
<span class="sd">    exhausting the available white pixels or reaching a maximum number of</span>
<span class="sd">    tests.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): An object containing parameters such as min, max coordinates, cutter</span>
<span class="sd">            diameter,</span>
<span class="sd">            border width, and optimisation settings.</span>
<span class="sd">        ar (np.ndarray): A 2D array representing the image where edge detection is to be</span>
<span class="sd">            performed.</span>
<span class="sd">        zimage (np.ndarray): A 2D array representing the z-coordinates corresponding to the image.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of chunks representing the detected edges in the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">minz</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">maxz</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">((</span><span class="n">o</span><span class="o">.</span><span class="n">cutter_diameter</span> <span class="o">/</span> <span class="mi">12</span><span class="p">)</span> <span class="o">/</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span><span class="p">)</span>  <span class="c1"># was commented</span>
    <span class="n">coef</span> <span class="o">=</span> <span class="mf">0.75</span>
    <span class="n">maxarx</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">maxary</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">directions</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="n">indices</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>  <span class="c1"># first get white pixels</span>
    <span class="n">startpix</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">totpix</span> <span class="o">=</span> <span class="n">startpix</span>
    <span class="n">chunk_builders</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nchunk</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">([(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zimage</span><span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">])])</span>  <span class="c1"># startposition</span>
    <span class="n">dindex</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># index in the directions list</span>
    <span class="n">last_direction</span> <span class="o">=</span> <span class="n">directions</span><span class="p">[</span><span class="n">dindex</span><span class="p">]</span>
    <span class="n">test_direction</span> <span class="o">=</span> <span class="n">directions</span><span class="p">[</span><span class="n">dindex</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">perc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">itests</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">totaltests</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">maxtotaltests</span> <span class="o">=</span> <span class="n">startpix</span> <span class="o">*</span> <span class="mi">4</span>

    <span class="n">ar</span><span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">while</span> <span class="n">totpix</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">totaltests</span> <span class="o">&lt;</span> <span class="n">maxtotaltests</span><span class="p">:</span>  <span class="c1"># a ratio when the algorithm is allowed to end</span>
        <span class="k">if</span> <span class="n">perc</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">totpix</span> <span class="o">/</span> <span class="n">startpix</span><span class="p">):</span>
            <span class="n">perc</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">totpix</span> <span class="o">/</span> <span class="n">startpix</span><span class="p">)</span>
            <span class="n">progress</span><span class="p">(</span><span class="s2">&quot;Pencil Path Searching&quot;</span><span class="p">,</span> <span class="n">perc</span><span class="p">)</span>
        <span class="c1"># progress(&#39;simulation &#39;,int(100*i/l))</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">testangulardistance</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># distance from initial direction in the list of direction</span>
        <span class="n">testleftright</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># test both sides from last vector</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">test_direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">test_direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">xs</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">xs</span> <span class="o">&lt;</span> <span class="n">ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">ys</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">ys</span> <span class="o">&lt;</span> <span class="n">ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span><span class="p">:</span>
                <span class="n">test</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">]</span>
                <span class="c1"># print(test)</span>
                <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
                    <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zimage</span><span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">]])</span>
                <span class="n">last_direction</span> <span class="o">=</span> <span class="n">test_direction</span>
                <span class="n">ar</span><span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Success&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">testlength</span><span class="p">,</span> <span class="n">testangle</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">lastvect</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">testvect</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">itests</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># nappend([xs,ys])#for debugging purpose</span>
                <span class="c1"># ar.shape[0]</span>
                <span class="n">test_direction</span> <span class="o">=</span> <span class="n">last_direction</span>
                <span class="k">if</span> <span class="n">testleftright</span><span class="p">:</span>
                    <span class="n">testangulardistance</span> <span class="o">=</span> <span class="o">-</span><span class="n">testangulardistance</span>
                    <span class="n">testleftright</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">testangulardistance</span> <span class="o">=</span> <span class="o">-</span><span class="n">testangulardistance</span>
                    <span class="n">testangulardistance</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># increment angle</span>
                    <span class="n">testleftright</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">testangulardistance</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">:</span>  <span class="c1"># /testlength</span>
                    <span class="n">testangulardistance</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                    <span class="n">totpix</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">chunk_builders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nchunk</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="n">xs</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">ys</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">nchunk</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">([(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zimage</span><span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">])])</span>  <span class="c1"># startposition</span>

                        <span class="n">ar</span><span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nchunk</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">([])</span>

                    <span class="n">test_direction</span> <span class="o">=</span> <span class="n">directions</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                    <span class="n">last_direction</span> <span class="o">=</span> <span class="n">directions</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                    <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">itests</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># print(&#39;reset&#39;)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">test_direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
                        <span class="n">testvect</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">r</span>
                    <span class="k">if</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">test_direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
                        <span class="n">testvect</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">r</span>
                    <span class="k">if</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">test_direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxarx</span> <span class="o">-</span> <span class="n">r</span><span class="p">:</span>
                        <span class="n">testvect</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">maxarx</span> <span class="o">-</span> <span class="n">r</span>
                    <span class="k">if</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">test_direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">maxary</span> <span class="o">-</span> <span class="n">r</span><span class="p">:</span>
                        <span class="n">testvect</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">maxary</span> <span class="o">-</span> <span class="n">r</span>

                <span class="n">dindexmod</span> <span class="o">=</span> <span class="n">dindex</span> <span class="o">+</span> <span class="n">testangulardistance</span>
                <span class="k">while</span> <span class="n">dindexmod</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">dindexmod</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">)</span>
                <span class="k">while</span> <span class="n">dindexmod</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">):</span>
                    <span class="n">dindexmod</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">)</span>

                <span class="n">test_direction</span> <span class="o">=</span> <span class="n">directions</span><span class="p">[</span><span class="n">dindexmod</span><span class="p">]</span>
                <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">test_direction</span><span class="p">,</span> <span class="n">last_direction</span><span class="p">,</span> <span class="n">testangulardistance</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">totpix</span><span class="p">)</span>
            <span class="n">itests</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">totaltests</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># print(&#39;100 succesfull tests done&#39;)</span>
            <span class="n">totpix</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="c1"># print(totpix)</span>
            <span class="c1"># print(totaltests)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">chunk_builders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nchunk</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chunk_builders</span><span class="p">:</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">points</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch</span><span class="p">)):</span>
            <span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">coef</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span><span class="p">)</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">+</span> <span class="n">minx</span><span class="p">,</span>
                <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">coef</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span><span class="p">)</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">+</span> <span class="n">miny</span><span class="p">,</span>
                <span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">to_chunk</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunk_builders</span><span class="p">]</span></div>



<div class="viewcode-block" id="get_offset_image_cavities">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.get_offset_image_cavities">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_offset_image_cavities</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>  <span class="c1"># for pencil operation mainly</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Detects areas in the offset image which are &#39;cavities&#39; due to curvature</span>
<span class="sd">    changes.</span>

<span class="sd">    This function analyzes the input image to identify regions where the</span>
<span class="sd">    curvature changes, indicating the presence of cavities. It computes</span>
<span class="sd">    vertical and horizontal differences in pixel values to detect edges and</span>
<span class="sd">    applies a threshold to filter out insignificant changes. The resulting</span>
<span class="sd">    areas are then processed to remove any chunks that do not meet the</span>
<span class="sd">    minimum criteria for cavity detection. The function returns a list of</span>
<span class="sd">    valid chunks that represent the detected cavities.</span>

<span class="sd">    Args:</span>
<span class="sd">        o: An object containing parameters and thresholds for the detection</span>
<span class="sd">            process.</span>
<span class="sd">        i (np.ndarray): A 2D array representing the image data to be analyzed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of detected chunks representing the cavities in the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># i=np.logical_xor(lastislice , islice)</span>
    <span class="n">progress</span><span class="p">(</span><span class="s2">&quot;Detect Corners in the Offset Image&quot;</span><span class="p">)</span>
    <span class="n">vertical</span> <span class="o">=</span> <span class="n">i</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">pencil_threshold</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">horizontal</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">pencil_threshold</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:]</span>
    <span class="c1"># if bpy.app.debug_value==2:</span>

    <span class="n">ar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">vertical</span><span class="p">,</span> <span class="n">horizontal</span><span class="p">)</span>

    <span class="k">if</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># this is newer strategy, finds edges nicely, but pff.going exacty on edge,</span>
        <span class="c1"># it has tons of spikes and simply is not better than the old one</span>
        <span class="n">iname</span> <span class="o">=</span> <span class="n">get_cache_path</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_pencilthres.exr&quot;</span>
        <span class="c1"># numpysave(ar,iname)#save for comparison before</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="n">image_edge_search_on_line</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">ar</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">iname</span> <span class="o">=</span> <span class="n">get_cache_path</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_pencilthres_comp.exr&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;New Pencil Strategy&quot;</span><span class="p">)</span>

    <span class="c1"># ##crop pixels that are on outer borders</span>
    <span class="k">for</span> <span class="n">chi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="n">chunks</span><span class="p">[</span><span class="n">chi</span><span class="p">]</span>
        <span class="n">chunk</span><span class="o">.</span><span class="n">clip_points</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="c1"># for si in range(len(points) - 1, -1, -1):</span>
        <span class="c1">#     if not (o.min.x &lt; points[si][0] &lt; o.max.x and o.min.y &lt; points[si][1] &lt; o.max.y):</span>
        <span class="c1">#         points.pop(si)</span>
        <span class="k">if</span> <span class="n">chunk</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">chi</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">chunks</span></div>



<div class="viewcode-block" id="crazy_stroke_image">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.crazy_stroke_image">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">crazy_stroke_image</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a toolpath for a milling operation using a crazy stroke</span>
<span class="sd">    strategy.</span>

<span class="sd">    This function computes a path for a milling cutter based on the provided</span>
<span class="sd">    parameters and the offset image. It utilizes a circular cutter</span>
<span class="sd">    representation and evaluates potential cutting positions based on</span>
<span class="sd">    various thresholds. The algorithm iteratively tests different angles and</span>
<span class="sd">    lengths for the cutter&#39;s movement until the desired cutting area is</span>
<span class="sd">    achieved or the maximum number of tests is reached.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): An object containing parameters such as cutter diameter,</span>
<span class="sd">            optimization settings, movement type, and thresholds for</span>
<span class="sd">            determining cutting effectiveness.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of chunks representing the computed toolpath for the milling</span>
<span class="sd">            operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># this surprisingly works, and can be used as a basis for something similar to adaptive milling strategy.</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">minz</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">maxz</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span>

    <span class="c1"># ceil((o.cutter_diameter/12)/o.optimisation.pixsize)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">o</span><span class="o">.</span><span class="n">cutter_diameter</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span>
    <span class="n">coef</span> <span class="o">=</span> <span class="mf">0.75</span>

    <span class="n">ar</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">offset_image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">maxarx</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">maxary</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">cutterArray</span> <span class="o">=</span> <span class="n">get_circle_binary</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">cutterArrayNegative</span> <span class="o">=</span> <span class="o">-</span><span class="n">cutterArray</span>

    <span class="n">cutterimagepix</span> <span class="o">=</span> <span class="n">cutterArray</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="c1"># a threshold which says if it is valuable to cut in a direction</span>
    <span class="n">satisfypix</span> <span class="o">=</span> <span class="n">cutterimagepix</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">crazy_threshold_1</span>
    <span class="n">toomuchpix</span> <span class="o">=</span> <span class="n">cutterimagepix</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">crazy_threshold_2</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>  <span class="c1"># first get white pixels</span>
    <span class="n">startpix</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1">#</span>
    <span class="n">totpix</span> <span class="o">=</span> <span class="n">startpix</span>
    <span class="n">chunk_builders</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span>
    <span class="k">if</span> <span class="n">xs</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">r</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span>
    <span class="k">if</span> <span class="n">ys</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">r</span>
    <span class="n">nchunk</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">([(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)])</span>  <span class="c1"># startposition</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># vector is 3d, blender somehow doesn&#39;t rotate 2d vectors with angles.</span>
    <span class="n">lastvect</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="c1"># multiply *2 not to get values &lt;1 pixel</span>
    <span class="n">testvect</span> <span class="o">=</span> <span class="n">lastvect</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span> <span class="o">*</span> <span class="n">r</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">Euler</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">perc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">itests</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">totaltests</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">maxtests</span> <span class="o">=</span> <span class="mi">500</span>
    <span class="n">maxtotaltests</span> <span class="o">=</span> <span class="mi">1000000</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">ar</span><span class="p">[</span><span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">ar</span><span class="p">[</span><span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span> <span class="o">*</span> <span class="n">cutterArrayNegative</span>
    <span class="p">)</span>
    <span class="c1"># range for angle of toolpath vector versus material vector</span>
    <span class="n">anglerange</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span> <span class="n">pi</span><span class="p">]</span>
    <span class="n">testangleinit</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">angleincrement</span> <span class="o">=</span> <span class="mf">0.05</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;CLIMB&quot;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">spindle_rotation</span> <span class="o">==</span> <span class="s2">&quot;CCW&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
        <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;CONVENTIONAL&quot;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">spindle_rotation</span> <span class="o">==</span> <span class="s2">&quot;CW&quot;</span>
    <span class="p">):</span>
        <span class="n">anglerange</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">testangleinit</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">angleincrement</span> <span class="o">=</span> <span class="o">-</span><span class="n">angleincrement</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;CONVENTIONAL&quot;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">spindle_rotation</span> <span class="o">==</span> <span class="s2">&quot;CCW&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
        <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;CLIMB&quot;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">spindle_rotation</span> <span class="o">==</span> <span class="s2">&quot;CW&quot;</span>
    <span class="p">):</span>
        <span class="n">anglerange</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pi</span><span class="p">]</span>
        <span class="n">testangleinit</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">angleincrement</span> <span class="o">=</span> <span class="n">angleincrement</span>
    <span class="k">while</span> <span class="n">totpix</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">totaltests</span> <span class="o">&lt;</span> <span class="n">maxtotaltests</span><span class="p">:</span>  <span class="c1"># a ratio when the algorithm is allowed to end</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># define a vector which gets varied throughout the testing, growing and growing angle to sides.</span>
        <span class="n">testangle</span> <span class="o">=</span> <span class="n">testangleinit</span>
        <span class="n">testleftright</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">testlength</span> <span class="o">=</span> <span class="n">r</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">testvect</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">testvect</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xs</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">xs</span> <span class="o">&lt;</span> <span class="n">ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">ys</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">ys</span> <span class="o">&lt;</span> <span class="n">ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">testar</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span> <span class="o">*</span> <span class="n">cutterArray</span>
                <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Test&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">testar</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">satisfypix</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">testlength</span><span class="p">,</span> <span class="n">testangle</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">lastvect</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">testvect</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">totpix</span><span class="p">)</span>

                <span class="n">eatpix</span> <span class="o">=</span> <span class="n">testar</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">cindices</span> <span class="o">=</span> <span class="n">testar</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                <span class="n">cx</span> <span class="o">=</span> <span class="n">cindices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">eatpix</span>
                <span class="n">cy</span> <span class="o">=</span> <span class="n">cindices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">eatpix</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="n">cx</span> <span class="o">-</span> <span class="n">r</span><span class="p">,</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">r</span><span class="p">))</span>
                <span class="n">angle</span> <span class="o">=</span> <span class="n">testvect</span><span class="o">.</span><span class="n">to_2d</span><span class="p">()</span><span class="o">.</span><span class="n">angle_signed</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                <span class="c1"># this could be righthanded milling? lets see :)</span>
                <span class="k">if</span> <span class="n">anglerange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="n">anglerange</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">toomuchpix</span> <span class="o">&gt;</span> <span class="n">eatpix</span> <span class="o">&gt;</span> <span class="n">satisfypix</span><span class="p">:</span>
                        <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">])</span>
                <span class="n">lastvect</span> <span class="o">=</span> <span class="n">testvect</span>
                <span class="n">ar</span><span class="p">[</span><span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span>
                    <span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span>
                <span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">cutterArray</span><span class="p">)</span>
                <span class="n">totpix</span> <span class="o">-=</span> <span class="n">eatpix</span>
                <span class="n">itests</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Success&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">testlength</span><span class="p">,</span> <span class="n">testangle</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">lastvect</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">testvect</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">itests</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># TODO: after all angles were tested into material higher than toomuchpix, it should cancel,</span>
                <span class="c1">#  otherwise there is no problem with long travel in free space.....</span>
                <span class="c1"># TODO:the testing should start not from the same angle as lastvector, but more towards material.</span>
                <span class="c1">#  So values closer to toomuchpix are obtained rather than satisfypix</span>
                <span class="n">testvect</span> <span class="o">=</span> <span class="n">lastvect</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span> <span class="o">*</span> <span class="n">testlength</span>
                <span class="n">right</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">testangleinit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># meander</span>
                    <span class="k">if</span> <span class="n">testleftright</span><span class="p">:</span>
                        <span class="n">testangle</span> <span class="o">=</span> <span class="o">-</span><span class="n">testangle</span>
                        <span class="n">testleftright</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">testangle</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">testangle</span><span class="p">)</span> <span class="o">+</span> <span class="n">angleincrement</span>  <span class="c1"># increment angle</span>
                        <span class="n">testleftright</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># climb/conv.</span>
                    <span class="n">testangle</span> <span class="o">+=</span> <span class="n">angleincrement</span>

                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">testangle</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">o</span><span class="o">.</span><span class="n">crazy_threshold_3</span><span class="p">:</span>  <span class="c1"># /testlength</span>
                    <span class="n">testangle</span> <span class="o">=</span> <span class="n">testangleinit</span>
                    <span class="n">testlength</span> <span class="o">+=</span> <span class="n">r</span> <span class="o">/</span> <span class="mf">4.0</span>
                <span class="k">if</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">testvect</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">testvect</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">r</span>
                <span class="k">if</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">testvect</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">testvect</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">r</span>
                <span class="k">if</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">testvect</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">maxarx</span> <span class="o">-</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">testvect</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">maxarx</span> <span class="o">-</span> <span class="n">r</span>
                <span class="k">if</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">testvect</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">maxary</span> <span class="o">-</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">testvect</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">maxary</span> <span class="o">-</span> <span class="n">r</span>

                <span class="n">rot</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">testangle</span>

                <span class="n">testvect</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>
                <span class="c1"># if 0:</span>
                <span class="c1">#     print(xs, ys, testlength, testangle)</span>
                <span class="c1">#     print(lastvect)</span>
                <span class="c1">#     print(testvect)</span>
                <span class="c1">#     print(totpix)</span>
            <span class="n">itests</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">totaltests</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">itests</span> <span class="o">&gt;</span> <span class="n">maxtests</span> <span class="ow">or</span> <span class="n">testlength</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">:</span>
                <span class="c1"># print(&#39;resetting location&#39;)</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                <span class="n">chunk_builders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nchunk</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xs</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span>
                    <span class="k">if</span> <span class="n">xs</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
                        <span class="n">xs</span> <span class="o">=</span> <span class="n">r</span>
                    <span class="n">ys</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span>
                    <span class="k">if</span> <span class="n">ys</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
                        <span class="n">ys</span> <span class="o">=</span> <span class="n">r</span>
                    <span class="n">nchunk</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">([(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)])</span>  <span class="c1"># startposition</span>
                    <span class="n">ar</span><span class="p">[</span><span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">ar</span><span class="p">[</span><span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span> <span class="o">*</span> <span class="n">cutterArrayNegative</span>
                    <span class="p">)</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">Euler</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
                    <span class="n">testvect</span> <span class="o">=</span> <span class="n">lastvect</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span> <span class="o">*</span> <span class="mi">4</span>  <span class="c1"># multiply *2 not to get values &lt;1 pixel</span>
                    <span class="n">testvect</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">lastvect</span> <span class="o">=</span> <span class="n">testvect</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">itests</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;100 Succesfull Tests Done&quot;</span><span class="p">)</span>
            <span class="n">totpix</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">totpix</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">totaltests</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">chunk_builders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nchunk</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chunk_builders</span><span class="p">:</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">points</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch</span><span class="p">)):</span>
            <span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">coef</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span><span class="p">)</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">+</span> <span class="n">minx</span><span class="p">,</span>
                <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">coef</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span><span class="p">)</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">+</span> <span class="n">miny</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">to_chunk</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunk_builders</span><span class="p">]</span></div>



<div class="viewcode-block" id="crazy_stroke_image_binary">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.crazy_stroke_image_binary">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">crazy_stroke_image_binary</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">ar</span><span class="p">,</span> <span class="n">avoidar</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform a milling operation using a binary image representation.</span>

<span class="sd">    This function implements a strategy for milling by navigating through a</span>
<span class="sd">    binary image. It starts from a defined point and attempts to move in</span>
<span class="sd">    various directions, evaluating the cutter load to determine the</span>
<span class="sd">    appropriate path. The algorithm continues until it either exhausts the</span>
<span class="sd">    available pixels to cut or reaches a predefined limit on the number of</span>
<span class="sd">    tests. The function modifies the input array to represent the areas that</span>
<span class="sd">    have been milled and returns the generated path as a list of chunks.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): An object containing parameters for the milling operation, including</span>
<span class="sd">            cutter diameter, thresholds, and movement type.</span>
<span class="sd">        ar (np.ndarray): A 2D binary array representing the image to be milled.</span>
<span class="sd">        avoidar (np.ndarray): A 2D binary array indicating areas to avoid during milling.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of chunks representing the path taken during the milling</span>
<span class="sd">            operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># this surprisingly works, and can be used as a basis for something similar to adaptive milling strategy.</span>
    <span class="c1"># works like this:</span>
    <span class="c1"># start &#39;somewhere&#39;</span>
    <span class="c1"># try to go in various directions.</span>
    <span class="c1"># if somewhere the cutter load is appropriate - it is correct magnitude and side, continue in that directon</span>
    <span class="c1"># try to continue straight or around that, looking</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">minz</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">maxz</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span>
    <span class="c1"># TODO this should be somewhere else, but here it is now to get at least some ambient for start of the operation.</span>
    <span class="n">ar</span><span class="p">[:</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ar</span><span class="p">[</span><span class="o">-</span><span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ar</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ar</span><span class="p">[:,</span> <span class="o">-</span><span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># ceil((o.cutter_diameter/12)/o.optimisation.pixsize)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">o</span><span class="o">.</span><span class="n">cutter_diameter</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">/</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span>
    <span class="n">coef</span> <span class="o">=</span> <span class="mf">0.75</span>
    <span class="n">maxarx</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">maxary</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">cutterArray</span> <span class="o">=</span> <span class="n">get_circle_binary</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">cutterArrayNegative</span> <span class="o">=</span> <span class="o">-</span><span class="n">cutterArray</span>

    <span class="n">cutterimagepix</span> <span class="o">=</span> <span class="n">cutterArray</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">anglelimit</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">crazy_threshold_3</span>
    <span class="c1"># a threshold which says if it is valuable to cut in a direction</span>
    <span class="n">satisfypix</span> <span class="o">=</span> <span class="n">cutterimagepix</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">crazy_threshold_1</span>
    <span class="n">toomuchpix</span> <span class="o">=</span> <span class="n">cutterimagepix</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">crazy_threshold_2</span>  <span class="c1"># same, but upper limit</span>
    <span class="c1"># (satisfypix+toomuchpix)/2.0# the ideal eating ratio</span>
    <span class="n">optimalpix</span> <span class="o">=</span> <span class="n">cutterimagepix</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">crazy_threshold_5</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>  <span class="c1"># first get white pixels</span>

    <span class="n">startpix</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>  <span class="c1">#</span>
    <span class="n">totpix</span> <span class="o">=</span> <span class="n">startpix</span>

    <span class="n">chunk_builders</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># try to find starting point here</span>

    <span class="n">xs</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">xs</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">r</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span>
    <span class="k">if</span> <span class="n">ys</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="n">r</span>

    <span class="n">nchunk</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">([(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)])</span>  <span class="c1"># startposition</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># vector is 3d, blender somehow doesn&#39;t rotate 2d vectors with angles.</span>
    <span class="n">lastvect</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="c1"># multiply *2 not to get values &lt;1 pixel</span>
    <span class="n">testvect</span> <span class="o">=</span> <span class="n">lastvect</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span> <span class="o">*</span> <span class="n">r</span> <span class="o">/</span> <span class="mf">4.0</span>
    <span class="n">rot</span> <span class="o">=</span> <span class="n">Euler</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">itests</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">totaltests</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">maxtests</span> <span class="o">=</span> <span class="mi">2000</span>
    <span class="n">maxtotaltests</span> <span class="o">=</span> <span class="mi">20000</span>  <span class="c1"># 1000000</span>

    <span class="n">margin</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># print(xs,ys,indices[0][0],indices[1][0],r)</span>
    <span class="n">ar</span><span class="p">[</span><span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">ys</span> <span class="o">+</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">ar</span><span class="p">[</span><span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">ys</span> <span class="o">+</span> <span class="n">r</span><span class="p">]</span> <span class="o">*</span> <span class="n">cutterArrayNegative</span>
    <span class="p">)</span>
    <span class="n">anglerange</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span> <span class="n">pi</span><span class="p">]</span>
    <span class="c1"># range for angle of toolpath vector versus material vector -</span>
    <span class="c1"># probably direction negative to the force applied on cutter by material.</span>
    <span class="n">testangleinit</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">angleincrement</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">crazy_threshold_4</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;CLIMB&quot;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">spindle_rotation</span> <span class="o">==</span> <span class="s2">&quot;CCW&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
        <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;CONVENTIONAL&quot;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">spindle_rotation</span> <span class="o">==</span> <span class="s2">&quot;CW&quot;</span>
    <span class="p">):</span>
        <span class="n">anglerange</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">testangleinit</span> <span class="o">=</span> <span class="n">anglelimit</span>
        <span class="n">angleincrement</span> <span class="o">=</span> <span class="o">-</span><span class="n">angleincrement</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;CONVENTIONAL&quot;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">spindle_rotation</span> <span class="o">==</span> <span class="s2">&quot;CCW&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
        <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;CLIMB&quot;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">spindle_rotation</span> <span class="o">==</span> <span class="s2">&quot;CW&quot;</span>
    <span class="p">):</span>
        <span class="n">anglerange</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">pi</span><span class="p">]</span>
        <span class="n">testangleinit</span> <span class="o">=</span> <span class="o">-</span><span class="n">anglelimit</span>
        <span class="n">angleincrement</span> <span class="o">=</span> <span class="n">angleincrement</span>

    <span class="k">while</span> <span class="n">totpix</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">totaltests</span> <span class="o">&lt;</span> <span class="n">maxtotaltests</span><span class="p">:</span>  <span class="c1"># a ratio when the algorithm is allowed to end</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># define a vector which gets varied throughout the testing, growing and growing angle to sides.</span>
        <span class="n">testangle</span> <span class="o">=</span> <span class="n">testangleinit</span>
        <span class="n">testleftright</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">testlength</span> <span class="o">=</span> <span class="n">r</span>

        <span class="n">foundsolutions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">testvect</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">testvect</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="c1"># print(xs,ys,ar.shape)</span>
            <span class="c1"># print(d)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">xs</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">+</span> <span class="n">margin</span>
                <span class="ow">and</span> <span class="n">xs</span> <span class="o">&lt;</span> <span class="n">ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span> <span class="o">-</span> <span class="n">margin</span>
                <span class="ow">and</span> <span class="n">ys</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">+</span> <span class="n">margin</span>
                <span class="ow">and</span> <span class="n">ys</span> <span class="o">&lt;</span> <span class="n">ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span> <span class="o">-</span> <span class="n">margin</span>
            <span class="p">):</span>
                <span class="c1"># avoidtest=avoidar[xs-r:xs+r,ys-r:ys+r]*cutterArray</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">avoidar</span><span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">]:</span>
                    <span class="n">testar</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">ys</span> <span class="o">+</span> <span class="n">r</span><span class="p">]</span> <span class="o">*</span> <span class="n">cutterArray</span>
                    <span class="n">eatpix</span> <span class="o">=</span> <span class="n">testar</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                    <span class="n">cindices</span> <span class="o">=</span> <span class="n">testar</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                    <span class="n">cx</span> <span class="o">=</span> <span class="n">cindices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">eatpix</span>
                    <span class="n">cy</span> <span class="o">=</span> <span class="n">cindices</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">eatpix</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="n">cx</span> <span class="o">-</span> <span class="n">r</span><span class="p">,</span> <span class="n">cy</span> <span class="o">-</span> <span class="n">r</span><span class="p">))</span>
                    <span class="c1"># print(testvect.length,testvect)</span>

                    <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">angle</span> <span class="o">=</span> <span class="n">testvect</span><span class="o">.</span><span class="n">to_2d</span><span class="p">()</span><span class="o">.</span><span class="n">angle_signed</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                        <span class="k">if</span> <span class="p">(</span>
                            <span class="n">anglerange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="n">anglerange</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="ow">and</span> <span class="n">toomuchpix</span> <span class="o">&gt;</span> <span class="n">eatpix</span> <span class="o">&gt;</span> <span class="n">satisfypix</span>
                        <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">eatpix</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">totpix</span> <span class="o">&lt;</span> <span class="n">startpix</span> <span class="o">*</span> <span class="mf">0.025</span><span class="p">):</span>
                            <span class="c1"># this could be righthanded milling?</span>
                            <span class="c1"># lets see :)</span>
                            <span class="c1"># print(xs,ys,angle)</span>
                            <span class="n">foundsolutions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">testvect</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">eatpix</span><span class="p">])</span>
                            <span class="c1"># or totpix &lt; startpix*0.025:</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">foundsolutions</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">:</span>
                                <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">itests</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">totaltests</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
                <span class="c1"># fist, try to inter/extrapolate the recieved results.</span>
                <span class="n">closest</span> <span class="o">=</span> <span class="mi">100000000</span>
                <span class="c1"># print(&#39;evaluate&#39;)</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">foundsolutions</span><span class="p">:</span>
                    <span class="c1"># print(abs(s[1]-optimalpix),optimalpix,abs(s[1]))</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">optimalpix</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">closest</span><span class="p">:</span>
                        <span class="n">bestsolution</span> <span class="o">=</span> <span class="n">s</span>
                        <span class="n">closest</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">optimalpix</span><span class="p">)</span>
                <span class="c1"># print(&#39;closest&#39;,closest)</span>

                <span class="c1"># v1#+(v2-v1)*ratio#rewriting with interpolated vect.</span>
                <span class="n">testvect</span> <span class="o">=</span> <span class="n">bestsolution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">xs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">testvect</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="n">ys</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">testvect</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">])</span>
                <span class="n">lastvect</span> <span class="o">=</span> <span class="n">testvect</span>

                <span class="n">ar</span><span class="p">[</span><span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">ys</span> <span class="o">+</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">ar</span><span class="p">[</span><span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">ys</span> <span class="o">+</span> <span class="n">r</span><span class="p">]</span> <span class="o">*</span> <span class="n">cutterArrayNegative</span>
                <span class="p">)</span>
                <span class="n">totpix</span> <span class="o">-=</span> <span class="n">bestsolution</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">itests</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># if 0:</span>
                <span class="c1">#     print(&#39;success&#39;)</span>
                <span class="c1">#     print(testar.sum(), satisfypix, toomuchpix)</span>
                <span class="c1">#     print(xs, ys, testlength, testangle)</span>
                <span class="c1">#     print(lastvect)</span>
                <span class="c1">#     print(testvect)</span>
                <span class="c1">#     print(itests)</span>
                <span class="n">totaltests</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># TODO: after all angles were tested into material higher than toomuchpix,</span>
                <span class="c1">#  it should cancel, otherwise there is no problem with long travel in free space.....</span>
                <span class="c1"># TODO:the testing should start not from the same angle as lastvector, but more towards material.</span>
                <span class="c1">#  So values closer to toomuchpix are obtained rather than satisfypix</span>
                <span class="n">testvect</span> <span class="o">=</span> <span class="n">lastvect</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span> <span class="o">*</span> <span class="n">testlength</span>

                <span class="k">if</span> <span class="n">testangleinit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># meander</span>
                    <span class="k">if</span> <span class="n">testleftright</span><span class="p">:</span>
                        <span class="n">testangle</span> <span class="o">=</span> <span class="o">-</span><span class="n">testangle</span> <span class="o">-</span> <span class="n">angleincrement</span>
                        <span class="n">testleftright</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">testangle</span> <span class="o">=</span> <span class="o">-</span><span class="n">testangle</span> <span class="o">+</span> <span class="n">angleincrement</span>  <span class="c1"># increment angle</span>
                        <span class="n">testleftright</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># climb/conv.</span>
                    <span class="n">testangle</span> <span class="o">+=</span> <span class="n">angleincrement</span>

                <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">testangle</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">o</span><span class="o">.</span><span class="n">crazy_threshold_3</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span>
                    <span class="n">testangle</span>
                <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">:</span>  <span class="c1"># /testlength</span>
                    <span class="n">testangle</span> <span class="o">=</span> <span class="n">testangleinit</span>
                    <span class="n">testlength</span> <span class="o">+=</span> <span class="n">r</span> <span class="o">/</span> <span class="mf">4.0</span>
                <span class="c1"># print(itests,testlength)</span>
                <span class="k">if</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">testvect</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">testvect</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">r</span>
                <span class="k">if</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">testvect</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">testvect</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">r</span>
                <span class="k">if</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">testvect</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">maxarx</span> <span class="o">-</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">testvect</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">maxarx</span> <span class="o">-</span> <span class="n">r</span>
                <span class="k">if</span> <span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">testvect</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">maxary</span> <span class="o">-</span> <span class="n">r</span><span class="p">:</span>
                    <span class="n">testvect</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">maxary</span> <span class="o">-</span> <span class="n">r</span>

                <span class="n">rot</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">testangle</span>
                <span class="c1"># if abs(testvect.normalized().y&lt;-0.99):</span>
                <span class="c1">#   print(testvect,rot.z)</span>
                <span class="n">testvect</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>

                <span class="c1"># if 0:</span>
                <span class="c1">#     print(xs, ys, testlength, testangle)</span>
                <span class="c1">#     print(lastvect)</span>
                <span class="c1">#     print(testvect)</span>
                <span class="c1">#     print(totpix)</span>
                <span class="k">if</span> <span class="n">itests</span> <span class="o">&gt;</span> <span class="n">maxtests</span> <span class="ow">or</span> <span class="n">testlength</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">:</span>
                    <span class="c1"># if len(foundsolutions)&gt;0:</span>

                    <span class="c1"># print(&#39;resetting location&#39;)</span>
                    <span class="c1"># print(testlength,r)</span>
                    <span class="n">andar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">avoidar</span><span class="p">))</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="n">andar</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">parent_child_distance</span><span class="p">([</span><span class="n">nchunk</span><span class="p">],</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">r</span><span class="p">)</span>
                        <span class="n">chunk_builders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nchunk</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">totpix</span> <span class="o">&gt;</span> <span class="n">startpix</span> <span class="o">*</span> <span class="mf">0.001</span><span class="p">:</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="n">ftests</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">while</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                            <span class="c1"># look for next start point:</span>
                            <span class="n">index</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                            <span class="c1"># print(index,len(indices[0]))</span>
                            <span class="c1"># print(indices[index])</span>
                            <span class="n">xs</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
                            <span class="n">ys</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">index</span><span class="p">]</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                            <span class="n">randomrot</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span>
                            <span class="n">e</span> <span class="o">=</span> <span class="n">Euler</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">randomrot</span><span class="p">))</span>
                            <span class="n">v</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                            <span class="n">xs</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                            <span class="n">ys</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">xs</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
                                <span class="n">xs</span> <span class="o">=</span> <span class="n">r</span>
                            <span class="k">if</span> <span class="n">ys</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">:</span>
                                <span class="n">ys</span> <span class="o">=</span> <span class="n">r</span>
                            <span class="k">if</span> <span class="n">avoidar</span><span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="c1"># print(toomuchpix,ar[xs-r:xs-r+d,ys-r:ys-r+d].sum()*pi/4,satisfypix)</span>
                                <span class="n">testarsum</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="n">ar</span><span class="p">[</span><span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="o">+</span> <span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span>
                                <span class="p">)</span>
                                <span class="k">if</span> <span class="n">toomuchpix</span> <span class="o">&gt;</span> <span class="n">testarsum</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span>
                                    <span class="n">totpix</span> <span class="o">&lt;</span> <span class="n">startpix</span> <span class="o">*</span> <span class="mf">0.025</span>
                                <span class="p">):</span>  <span class="c1"># 0 now instead of satisfypix</span>
                                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                                    <span class="c1"># print(xs,ys,indices[0][index],indices[1][index])</span>

                                    <span class="n">nchunk</span> <span class="o">=</span> <span class="n">CamPathChunk</span><span class="p">([(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)])</span>  <span class="c1"># startposition</span>
                                    <span class="n">ar</span><span class="p">[</span><span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">ys</span> <span class="o">+</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                        <span class="n">ar</span><span class="p">[</span><span class="n">xs</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">ys</span> <span class="o">-</span> <span class="n">r</span> <span class="p">:</span> <span class="n">ys</span> <span class="o">+</span> <span class="n">r</span><span class="p">]</span> <span class="o">*</span> <span class="n">cutterArrayNegative</span>
                                    <span class="p">)</span>
                                    <span class="c1"># lastvect=Vector((r,0,0))#vector is 3d,</span>
                                    <span class="c1"># blender somehow doesn&#39;t rotate 2d vectors with angles.</span>
                                    <span class="n">randomrot</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span>
                                    <span class="n">e</span> <span class="o">=</span> <span class="n">Euler</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">randomrot</span><span class="p">))</span>
                                    <span class="n">testvect</span> <span class="o">=</span> <span class="p">(</span>
                                        <span class="n">lastvect</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span>
                                    <span class="p">)</span>  <span class="c1"># multiply *2 not to get values &lt;1 pixel</span>
                                    <span class="n">testvect</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                                    <span class="n">lastvect</span> <span class="o">=</span> <span class="n">testvect</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">ftests</span> <span class="o">&gt;</span> <span class="mi">2000</span><span class="p">:</span>
                                <span class="n">totpix</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># this quits the process now.</span>
                            <span class="n">ftests</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">itests</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;100 Succesfull Tests Done&quot;</span><span class="p">)</span>
            <span class="n">totpix</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">totpix</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">totaltests</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nchunk</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">parent_child_distance</span><span class="p">([</span><span class="n">nchunk</span><span class="p">],</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">r</span><span class="p">)</span>
        <span class="n">chunk_builders</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nchunk</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chunk_builders</span><span class="p">:</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">points</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch</span><span class="p">)):</span>
            <span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">coef</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span><span class="p">)</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">+</span> <span class="n">minx</span><span class="p">,</span>
                <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">coef</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span><span class="p">)</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">+</span> <span class="n">miny</span><span class="p">,</span>
                <span class="n">o</span><span class="o">.</span><span class="n">min_z</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">to_chunk</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunk_builders</span><span class="p">]</span></div>



<div class="viewcode-block" id="image_to_chunks">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.image_to_chunks">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">image_to_chunks</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">with_border</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert an image into chunks based on detected edges.</span>

<span class="sd">    This function processes a given image to identify edges and convert them</span>
<span class="sd">    into polychunks, which are essentially collections of connected edge</span>
<span class="sd">    segments. It utilizes the properties of the input object `o` to</span>
<span class="sd">    determine the boundaries and size of the chunks. The function can</span>
<span class="sd">    optionally include borders in the edge detection process. The output is</span>
<span class="sd">    a list of chunks that represent the detected polygons in the image.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): An object containing properties such as min, max, borderwidth,</span>
<span class="sd">            and optimisation settings.</span>
<span class="sd">        image (np.ndarray): A 2D array representing the image to be processed,</span>
<span class="sd">            expected to be in a format compatible with uint8.</span>
<span class="sd">        with_border (bool?): A flag indicating whether to include borders</span>
<span class="sd">            in the edge detection. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of chunks, where each chunk is represented as a collection of</span>
<span class="sd">            points that outline the detected edges in the image.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">minz</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">maxz</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span>
    <span class="n">pixsize</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span>

    <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="c1"># progress(&#39;detecting outline&#39;)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ar</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">image</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>

    <span class="n">indices1</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">borderspread</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="c1"># o.cutter_diameter/o.optimisation.pixsize#when the border was excluded precisely, sometimes it did remove some silhouette parts</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span> <span class="o">-</span> <span class="n">borderspread</span>
    <span class="c1"># to prevent outline of the border was 3 before and also (o.cutter_diameter/2)/pixsize+o.borderwidth</span>
    <span class="k">if</span> <span class="n">with_border</span><span class="p">:</span>
        <span class="c1">#   print(&#39;border&#39;)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">coef</span> <span class="o">=</span> <span class="mf">0.75</span>  <span class="c1"># compensates for imprecisions</span>
    <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices1</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">indices1</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nb">id</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">indices1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="nb">id</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">w</span> <span class="o">-</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">h</span> <span class="o">-</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)))</span>

    <span class="n">ar</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>
    <span class="n">indices2</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices2</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">indices2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nb">id</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">indices2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="nb">id</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">w</span> <span class="o">-</span> <span class="n">r</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">h</span> <span class="o">-</span> <span class="n">r</span><span class="p">:</span>
            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)))</span>

    <span class="n">polychunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># progress(len(edges))</span>

    <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">verts1</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">verts2</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">verts1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">verts2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1"># first and his reference</span>

        <span class="n">d</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">specialcase</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># progress(&#39;condensing outline&#39;)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20000000</span><span class="p">:</span>
            <span class="n">verts</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[])</span>
            <span class="n">closed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># print(verts)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># this will be good for not closed loops...some time</span>
                <span class="n">closed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">verts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">verts</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">verts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">specialcase</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">white</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">comesfromtop</span> <span class="o">=</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">comesfrombottom</span> <span class="o">=</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">comesfromleft</span> <span class="o">=</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">comesfromright</span> <span class="o">=</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">take</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ch</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ch</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">pass</span>
                        <span class="n">verts</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">take</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">white</span> <span class="ow">and</span> <span class="n">comesfromtop</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                            <span class="n">white</span> <span class="ow">and</span> <span class="n">comesfrombottom</span>
                        <span class="p">):</span>  <span class="c1"># goes right</span>
                            <span class="k">if</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="n">take</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">white</span> <span class="ow">and</span> <span class="n">comesfrombottom</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                            <span class="n">white</span> <span class="ow">and</span> <span class="n">comesfromtop</span>
                        <span class="p">):</span>  <span class="c1"># goes left</span>
                            <span class="k">if</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">:</span>
                                <span class="n">take</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">white</span> <span class="ow">and</span> <span class="n">comesfromleft</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
                            <span class="n">white</span> <span class="ow">and</span> <span class="n">comesfromright</span>
                        <span class="p">):</span>  <span class="c1"># goes down</span>
                            <span class="k">if</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">:</span>
                                <span class="n">take</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">white</span> <span class="ow">and</span> <span class="n">comesfromright</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">white</span> <span class="ow">and</span> <span class="n">comesfromleft</span><span class="p">):</span>  <span class="c1"># goes up</span>
                            <span class="k">if</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                <span class="n">take</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="n">take</span><span class="p">:</span>
                            <span class="n">ch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                            <span class="n">verts</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># here it has to be 2 always</span>
                <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">vi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">verts</span><span class="p">[</span><span class="n">vi</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ch</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ch</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="k">pass</span>
                            <span class="n">verts</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">ch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                            <span class="n">done</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">verts</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                            <span class="c1"># or len(verts)&lt;=1:</span>
                            <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ch</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ch</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                                <span class="n">closed</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">closed</span><span class="p">:</span>
                <span class="n">polychunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">si</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ch</span><span class="p">):</span>
                    <span class="c1"># print(si)</span>
                    <span class="k">if</span> <span class="n">si</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># first one was popped</span>
                        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># this makes the case much less probable, but i think not impossible</span>
                            <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">newch</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">while</span> <span class="ow">not</span> <span class="n">newch</span><span class="p">:</span>
                        <span class="n">v1</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">ch</span> <span class="o">=</span> <span class="p">[</span><span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                            <span class="n">newch</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># print(&#39; la problema grandiosa&#39;)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10000</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ch</span><span class="p">))</span>
                <span class="c1"># print(polychunks)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">vecchunks</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">polychunks</span><span class="p">:</span>
            <span class="n">vecchunk</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">vecchunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vecchunk</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch</span><span class="p">)):</span>
                <span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">coef</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixsize</span> <span class="o">+</span> <span class="n">minx</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">coef</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixsize</span> <span class="o">+</span> <span class="n">miny</span><span class="p">,</span>
                    <span class="mi">0</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">vecchunk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="c1"># print(&#39;optimizing outline&#39;)</span>

        <span class="c1"># print(&#39;directsimplify&#39;)</span>
        <span class="n">reduxratio</span> <span class="o">=</span> <span class="mf">1.25</span>  <span class="c1"># was 1.25</span>
        <span class="n">soptions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;distance&quot;</span><span class="p">,</span>
            <span class="s2">&quot;distance&quot;</span><span class="p">,</span>
            <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">*</span> <span class="n">reduxratio</span><span class="p">,</span>
            <span class="mi">5</span><span class="p">,</span>
            <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">*</span> <span class="n">reduxratio</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">nchunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vecchunks</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">curve_simplify</span><span class="o">.</span><span class="n">simplify_RDP</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">soptions</span><span class="p">)</span>
            <span class="c1"># print(s)</span>
            <span class="n">nch</span> <span class="o">=</span> <span class="n">CamPathChunkBuilder</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
                <span class="n">nch</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">ch</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">ch</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nch</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">nchunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nch</span><span class="o">.</span><span class="n">to_chunk</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">nchunks</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span></div>



<div class="viewcode-block" id="image_to_shapely">
<a class="viewcode-back" href="../../autoapi/fabex/cam_chunk/index.html#fabex.cam_chunk.image_to_shapely">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">image_to_shapely</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">with_border</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert an image to Shapely polygons.</span>

<span class="sd">    This function takes an image and converts it into a series of Shapely</span>
<span class="sd">    polygon objects. It first processes the image into chunks and then</span>
<span class="sd">    transforms those chunks into polygon geometries. The `with_border`</span>
<span class="sd">    parameter allows for the inclusion of borders in the resulting polygons.</span>

<span class="sd">    Args:</span>
<span class="sd">        o: The input image to be processed.</span>
<span class="sd">        i: Additional input parameters for processing the image.</span>
<span class="sd">        with_border (bool): A flag indicating whether to include</span>
<span class="sd">            borders in the resulting polygons. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of Shapely polygon objects created from the</span>
<span class="sd">            image chunks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">polychunks</span> <span class="o">=</span> <span class="n">image_to_chunks</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">with_border</span><span class="p">)</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="n">chunks_to_shapely</span><span class="p">(</span><span class="n">polychunks</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">polys</span></div>

</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Vilem Novak, Alain Pelletier & Contributors
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2025.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>